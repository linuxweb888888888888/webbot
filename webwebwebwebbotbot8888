/******************************************************************************************
    ‚ö° IRONCLAD PROFIT GUARD v2.4 (Limit Entries + No Cycle)
    
    Changes:
    1. REMOVED TP Cycle (TP is always active).
    2. CHANGED Entry logic: Now uses Limit Orders with Chase Logic (same as TP).
    3. Maintained Panic Logic and Risk Management.
******************************************************************************************/

const fs = require('fs');
const dotenv = require('dotenv');
const express = require('express');
const http = require('http');
const https = require('https'); 
const { Server } = require('socket.io');
const ccxt = require('ccxt');
const minimist = require('minimist');

// ================= CONFIGURATION =================
const args = minimist(process.argv.slice(2));

// Default high-volatility list
const rawCoinArg = args.coin || 'BTC ETH SOL XRP ADA DOGE LINK DOT 1000SATS PEPE';
const COIN_LIST = rawCoinArg.toString().split(/[\s,]+/).filter(c => c).map(c => c.toUpperCase());
const PORT = parseInt(args.port) || 3000;

const CONFIG = {
    TAKE_PROFIT_ROI: 0.8,       // Target ROI % 
    LIQ_RISK_TRIGGER: 60,       // Liquidation Risk Threshold % (Starts DCA)
    MAX_RISK_EXIT: 200,         // Risk cap
    TARGET_RECOVERY_ROI: 35,    // DCA Recovery Target %
    LEVERAGE: 5,                // Leverage
    ENTRY_MULTIPLIER: 1,        // üëà KEEP AT 1 to use EXACT Min Qty
    POLL_RATE: 3500,            // 3.5s Refresh Rate
    HTTP_TIMEOUT: 10000,        // Request Timeout
    EST_FEE_RATE: 0.0006,       // 0.06% Taker Fee
    MIN_PRICE_MOVE: 0.002,      // 0.2% Move required
    TP_CONFIRM_MS: 3000,        // 3 Seconds Wait time before TP
    PANIC_COOLDOWN_MS: 14 * 60 * 1000 // 14 Minutes Interval
};

// üåç GLOBAL STATE
let GLOBAL_OPEN_LONGS = 0;
let GLOBAL_OPEN_SHORTS = 0;
let GLOBAL_NEXT_AUTO_CLOSE = Date.now() + CONFIG.PANIC_COOLDOWN_MS;

const httpsAgent = new https.Agent({ keepAlive: true, maxSockets: 50, timeout: CONFIG.HTTP_TIMEOUT });

// ================= UTILITIES =================

function parseEnvFile(filePath) {
    try {
        const config = dotenv.parse(fs.readFileSync(filePath));
        return { key: config.PHEMEX_KEY, secret: config.PHEMEX_SECRET };
    } catch (e) { return { key: null, secret: null }; }
}

function calculateLiqRisk(side, entry, mark, leverage, mmr = 0.005) {
    if (!entry || !mark) return 0;
    let liqPrice = side === 'long' 
        ? entry * (1 - (1 / leverage) + mmr) 
        : entry * (1 + (1 / leverage) - mmr);
    
    const distToLiq = Math.abs(mark - liqPrice);
    const distTotal = Math.abs(entry - liqPrice);
    
    if (distTotal === 0) return 100;
    let risk = ((distTotal - distToLiq) / distTotal) * 100;
    return Math.max(0, Math.min(100, risk));
}

function calculateRecoveryQty(side, currentPrice, currentEntry, currentQty, targetRoi, leverage) {
    const roiDecimal = targetRoi / 100;
    let targetAvgEntry = side === 'long' 
        ? currentPrice / ((roiDecimal / leverage) + 1)
        : currentPrice / (1 - (roiDecimal / leverage));
    
    if ((side === 'long' && targetAvgEntry >= currentPrice) || 
        (side === 'short' && targetAvgEntry <= currentPrice)) return 0;
    
    if (Math.abs(targetAvgEntry - currentPrice) < 0.00000001) return 0;

    const numerator = currentQty * (currentEntry - targetAvgEntry);
    const denominator = Math.abs(targetAvgEntry - currentPrice);
    return Math.abs(numerator / denominator);
}

// ================= ACCOUNT CLASS =================

class TradingAccount {
    constructor(id, filename, creds) {
        this.id = id;
        this.name = filename;
        this.isReady = false;
        this.exchange = new ccxt.phemex({
            apiKey: creds.key, secret: creds.secret, enableRateLimit: true, agent: httpsAgent, 
            options: { defaultType: 'swap', adjustForTimeDifference: true } 
        });
        this.data = {
            wallet: { balance: 0, equity: 0, totalUpnl: 0 },
            activeCoinsCount: 0, maxRisk: 0, tickDuration: 0, 
            coins: {}, history: [] 
        };
        this.symbols = {}; 
        this.prevPositions = {}; 
    }

    async init() {
        try {
            console.log(`[${this.id}] üì° Loading Markets...`);
            const markets = await this.exchange.loadMarkets();
            
            const initPromises = COIN_LIST.map(async (coin) => {
                const swapSymbol = Object.keys(markets).find(s => 
                    markets[s].base === coin && 
                    markets[s].quote === 'USDT' && 
                    markets[s].linear === true
                );
                
                if (swapSymbol) {
                    this.symbols[coin] = swapSymbol;
                    const marketInfo = markets[swapSymbol];
                    
                    let minAmount = marketInfo.limits.amount.min;
                    if (!minAmount) minAmount = marketInfo.precision.amount;
                    if (!minAmount) minAmount = 1; 

                    this.data.coins[coin] = {
                        symbol: swapSymbol, 
                        limits: { minAmount: parseFloat(minAmount) }, 
                        market: { price: 0, markPrice: 0, bid: 0, ask: 0 },
                        position: { qty: 0, entry: 0, upnl: 0, roi: 0, realRoi: 0, risk: 0, side: 'NONE' },
                        bot: { 
                            status: 'IDLE', lastAction: 0, retryUntil: 0, openTime: 0, 
                            tpStart: 0, tpOrderId: null, tpLastPrice: 0,
                            dcaOrderId: null, dcaLastPrice: 0,
                            entryOrderId: null, entryLastPrice: 0 // Added Entry Order tracking
                        }
                    };
                    this.prevPositions[coin] = { qty: 0, entry: 0, side: 'NONE', openTime: 0 };

                    try { await this.exchange.setLeverage(CONFIG.LEVERAGE, swapSymbol); } catch(err) {}

                } else {
                    console.warn(`[${this.id}] ‚ö†Ô∏è Symbol not found for ${coin}`);
                }
            });

            await Promise.all(initPromises);
            this.isReady = true;
            console.log(`[${this.id}] ‚úÖ Initialized. Using Exact Min Qty.`);
        } catch (e) { console.error(`[${this.id}] üíÄ Init Failed:`, e.message); }
    }

    async closeAllPositions() {
        if (!this.isReady) return;
        console.log(`[${this.id}] üö® MANUAL CLOSE TRIGGERED!`);
        try {
            const knownSymbols = Object.values(this.symbols);
            const positions = await this.exchange.fetchPositions(knownSymbols);
            const activePositions = positions.filter(p => Math.abs(parseFloat(p.contracts || p.amount)) > 0);
            
            await Promise.all(activePositions.map(async (pos) => {
                const amount = Math.abs(parseFloat(pos.contracts || pos.amount));
                const side = pos.side === 'long' ? 'sell' : 'buy'; 
                try {
                    await this.exchange.cancelAllOrders(pos.symbol);
                    await this.exchange.createOrder(pos.symbol, 'market', side, amount, undefined, {'reduceOnly': true});
                    console.log(`[${this.id}] üí• Closed ${pos.symbol}`);
                } catch (err) { console.error(`[${this.id}] ‚ùå Close Failed ${pos.symbol}: ${err.message}`); }
            }));

            Object.values(this.data.coins).forEach(c => {
                c.bot.status = 'IDLE'; 
                c.bot.retryUntil = Date.now() + 2000;
                c.bot.tpOrderId = null; c.bot.dcaOrderId = null; c.bot.entryOrderId = null;
            });
        } catch (e) { console.error(`[${this.id}] Cleanup Error:`, e.message); }
    }

    async update() {
        if (!this.isReady) return;
        const startTick = Date.now();
        try {
            const symbolsToFetch = Object.values(this.symbols);
            if(symbolsToFetch.length === 0) return;

            const [balanceData, positionsData, tickersData] = await Promise.all([
                this.exchange.fetchBalance({ type: 'swap', code: 'USDT' }).catch(e => null),
                this.exchange.fetchPositions(symbolsToFetch).catch(e => []),
                this.exchange.fetchTickers(symbolsToFetch).catch(e => {})
            ]);

            if (!balanceData) return; 
            
            this.data.wallet.balance = parseFloat(balanceData.USDT?.total || balanceData.total?.USDT || 0);
            this.data.wallet.totalUpnl = 0;
            this.data.activeCoinsCount = 0;
            this.data.maxRisk = 0;

            const posMap = new Map();
            positionsData.forEach(p => posMap.set(p.symbol, p));
            
            const logicPromises = COIN_LIST.map(async (coin) => {
                const coinState = this.data.coins[coin];
                if (!coinState) return;
                
                const SYMBOL = coinState.symbol;
                const ticker = tickersData[SYMBOL];
                
                if (ticker) {
                    coinState.market.price = ticker.last;
                    coinState.market.markPrice = ticker.info.markPrice ? parseFloat(ticker.info.markPrice) : ticker.last;
                    coinState.market.bid = ticker.bid || ticker.last;
                    coinState.market.ask = ticker.ask || ticker.last;
                }

                const pos = posMap.get(SYMBOL);
                const hasPos = pos && parseFloat(pos.contracts || pos.amount) > 0;
                const prevPos = this.prevPositions[coin];

                if (hasPos) {
                    const rawSize = Math.abs(parseFloat(pos.contracts || pos.amount));
                    
                    if (prevPos.qty === 0) {
                        coinState.bot.openTime = Date.now();
                        coinState.bot.status = 'HOLDING'; 
                        // If we just got a position, clear any lingering entry order references
                        coinState.bot.entryOrderId = null;
                        coinState.bot.entryLastPrice = 0;
                    }

                    coinState.position.qty = rawSize;
                    coinState.position.entry = parseFloat(pos.entryPrice);
                    coinState.position.side = pos.side;

                    let exitPrice = pos.side === 'long' ? coinState.market.bid : coinState.market.ask;
                    let uPnL = pos.side === 'long' 
                        ? (exitPrice - coinState.position.entry) * rawSize 
                        : (coinState.position.entry - exitPrice) * rawSize;
                    
                    const marginUsed = (rawSize * coinState.position.entry) / CONFIG.LEVERAGE;
                    
                    let markPnL = pos.side === 'long' 
                        ? (coinState.market.markPrice - coinState.position.entry) * rawSize 
                        : (coinState.position.entry - coinState.market.markPrice) * rawSize;

                    coinState.position.roi = marginUsed > 0 ? (markPnL / marginUsed) * 100 : 0;
                    coinState.position.realRoi = marginUsed > 0 ? (uPnL / marginUsed) * 100 : 0;
                    coinState.position.upnl = uPnL;
                    coinState.position.risk = calculateLiqRisk(pos.side, coinState.position.entry, coinState.market.markPrice, CONFIG.LEVERAGE);

                    this.data.wallet.totalUpnl += uPnL;
                    this.data.activeCoinsCount++;
                    if(coinState.position.risk > this.data.maxRisk) this.data.maxRisk = coinState.position.risk;

                    this.prevPositions[coin] = { qty: rawSize, entry: coinState.position.entry, side: pos.side, openTime: coinState.bot.openTime || Date.now() };

                } else {
                    if (prevPos.qty > 0) {
                        const closePrice = (prevPos.side === 'long') ? coinState.market.bid : coinState.market.ask;
                        this.recordHistory(coin, prevPos, closePrice);
                        // Cancel any pending exit orders on close
                        if (coinState.bot.tpOrderId) this.exchange.cancelOrder(coinState.bot.tpOrderId, SYMBOL).catch(() => {});
                        if (coinState.bot.dcaOrderId) this.exchange.cancelOrder(coinState.bot.dcaOrderId, SYMBOL).catch(() => {});
                    }
                    coinState.position.qty = 0; coinState.position.upnl = 0; coinState.position.roi = 0; coinState.position.realRoi = 0; coinState.position.risk = 0; coinState.position.side = 'NONE';
                    
                    if (coinState.bot.status !== 'IDLE' && coinState.bot.status !== 'ENTERING') {
                        coinState.bot.status = 'IDLE';
                        coinState.bot.retryUntil = 0;
                    }
                    
                    coinState.bot.tpStart = 0;
                    coinState.bot.tpOrderId = null; coinState.bot.tpLastPrice = 0;
                    coinState.bot.dcaOrderId = null; coinState.bot.dcaLastPrice = 0;
                    // Note: We do NOT reset entryOrderId here, as it might be currently active trying to get in

                    this.prevPositions[coin] = { qty: 0, entry: 0, side: 'NONE', openTime: 0 };
                }
                
                await this.executeLogic(coin, coinState, SYMBOL);
            });

            await Promise.all(logicPromises);
            this.data.wallet.equity = this.data.wallet.balance + this.data.wallet.totalUpnl;
            this.data.tickDuration = Date.now() - startTick;
        } catch (e) { console.error(`[${this.id}] Cycle Error:`, e.message); }
    }

    recordHistory(coin, prevPos, closePrice) {
        let pnl = 0;
        let sideLabel = prevPos.side === 'long' ? `LONG ${coin}` : `SHORT ${coin}`;
        if (prevPos.side === 'long') pnl = (closePrice - prevPos.entry) * prevPos.qty;
        else pnl = (prevPos.entry - closePrice) * prevPos.qty;

        const entryVal = prevPos.qty * prevPos.entry;
        const estFee = (entryVal + (prevPos.qty * closePrice)) * CONFIG.EST_FEE_RATE;
        const netPnl = pnl - estFee;
        const margin = entryVal / CONFIG.LEVERAGE;
        const roi = margin > 0 ? (netPnl / margin) * 100 : 0;

        const tradeRecord = {
            symbol: `${coin}USDT`, marginType: 'Cross', totalSize: sideLabel,
            openPrice: prevPos.entry, closePrice: closePrice, pnl: netPnl, roi: roi,
            openTime: prevPos.openTime, closeTime: Date.now()
        };
        this.data.history.unshift(tradeRecord);
        if (this.data.history.length > 20) this.data.history.pop();
    }

    async executeLogic(coin, state, symbol) {
        if (Date.now() < state.bot.retryUntil) return;
        const minQtyLimit = state.limits.minAmount; 
        if (!state.market.price || state.market.price === 0) return;

        // A. ENTRY LOGIC (Modified to use Limit Orders like TP)
        if (state.position.qty === 0) {
            
            // Determine Direction
            let side = 'buy'; 
            if (GLOBAL_OPEN_SHORTS < GLOBAL_OPEN_LONGS) side = 'sell'; 
            else if (GLOBAL_OPEN_LONGS < GLOBAL_OPEN_SHORTS) side = 'buy'; 
            else side = (COIN_LIST.indexOf(coin) % 2 === 0) ? 'buy' : 'sell';

            const limitPrice = side === 'buy' ? state.market.bid : state.market.ask;

            // 1. Cancel existing entry if price moved
            if (state.bot.entryOrderId) {
                if (Math.abs(limitPrice - state.bot.entryLastPrice) > (state.market.price * 0.0005)) {
                    // Price moved 0.05%, cancel and reposition
                    try {
                        await this.exchange.cancelOrder(state.bot.entryOrderId, symbol);
                        state.bot.entryOrderId = null;
                        state.bot.status = 'IDLE'; // Ready to place new one
                        console.log(`[${this.id}] ‚ôªÔ∏è Repositioning Entry for ${coin}`);
                    } catch (e) {
                        // Order might have filled or already been cancelled
                        state.bot.entryOrderId = null;
                    }
                }
            }

            // 2. Place new Limit Entry
            if (!state.bot.entryOrderId && state.bot.status === 'IDLE') {
                try {
                     state.bot.status = 'ENTERING';

                     const rawQty = state.limits.minAmount * CONFIG.ENTRY_MULTIPLIER;
                     const safeQty = parseFloat(this.exchange.amountToPrecision(symbol, rawQty));

                     if (safeQty <= 0) { state.bot.status = 'IDLE'; return; }
                     
                     console.log(`[${this.id}] ‚è≥ Entry LIMIT ${coin} ${side} @ ${limitPrice}`);
                     const order = await this.exchange.createOrder(symbol, 'limit', side, safeQty, limitPrice);
                     
                     state.bot.entryOrderId = order.id;
                     state.bot.entryLastPrice = limitPrice;
                     state.bot.status = 'ENTRY_PENDING';
                     state.bot.openTime = Date.now(); 

                } catch(e) {
                    if (e.message.includes('Cost less than') || e.message.includes('10002')) {
                         console.warn(`[${this.id}] ‚ö†Ô∏è ${coin} Min Qty too cheap. Skipping.`);
                    } else {
                         console.error(`[${this.id}] ‚ùå Entry Error ${coin}:`, e.message);
                    }
                    state.bot.status = 'IDLE'; 
                    state.bot.retryUntil = Date.now() + 3000; 
                }
            }
        }
        // B. MANAGEMENT LOGIC
        else {
            // Ensure any pending entry order is cleared if we have a position
            if (state.bot.entryOrderId) {
                state.bot.entryOrderId = null;
                state.bot.entryLastPrice = 0;
            }

            const isLong = state.position.side === 'long';
            const exitPrice = isLong ? state.market.bid : state.market.ask;

            let canTakeProfit = false;
            
            // Standard TP Logic (No Cycle)
            if (state.position.realRoi >= CONFIG.TAKE_PROFIT_ROI) {
                const requiredMove = state.position.entry * CONFIG.MIN_PRICE_MOVE;
                const isPriceMoveOk = isLong ? (exitPrice >= state.position.entry + requiredMove) : (exitPrice <= state.position.entry - requiredMove);
                
                let grossPnl = isLong ? (exitPrice - state.position.entry) * state.position.qty : (state.position.entry - exitPrice) * state.position.qty;
                const fee = (state.position.entry * state.position.qty + exitPrice * state.position.qty) * CONFIG.EST_FEE_RATE;
                const netPnl = grossPnl - fee;

                if (isPriceMoveOk && netPnl > 0) {
                    if (state.bot.tpStart === 0) {
                        state.bot.tpStart = Date.now();
                    } else if (Date.now() - state.bot.tpStart >= CONFIG.TP_CONFIRM_MS) {
                        canTakeProfit = true;
                    }
                } else { state.bot.tpStart = 0; }
            } else { state.bot.tpStart = 0; }

            // Execute TP
            if (canTakeProfit) {
                const limitPrice = exitPrice;
                const side = isLong ? 'sell' : 'buy';
                try {
                    if (state.bot.tpOrderId) {
                        if (Math.abs(limitPrice - state.bot.tpLastPrice) > (state.market.price * 0.0005)) {
                            await this.exchange.cancelOrder(state.bot.tpOrderId, symbol).catch(()=>{});
                            state.bot.tpOrderId = null; 
                        }
                    }
                    if (!state.bot.tpOrderId) {
                        console.log(`[${this.id}] üí∞ ${coin} TP @ ${limitPrice} (ROI: ${state.position.realRoi.toFixed(2)}%)`);
                        const order = await this.exchange.createOrder(symbol, 'limit', side, state.position.qty, limitPrice, {'reduceOnly': true});
                        state.bot.tpOrderId = order.id; state.bot.tpLastPrice = limitPrice; state.bot.status = 'TP_SENT';
                    }
                } catch(e) { console.error(`[${this.id}] TP Error:`, e.message); state.bot.status = 'HOLDING'; state.bot.tpOrderId = null; }
            } else {
                // If ROI dropped, cancel existing TP
                if (state.bot.tpOrderId) {
                    await this.exchange.cancelOrder(state.bot.tpOrderId, symbol).catch(()=>{});
                    state.bot.tpOrderId = null; state.bot.tpLastPrice = 0; state.bot.status = 'HOLDING';
                }
            }

            // DCA LOGIC
            if (state.position.risk >= CONFIG.LIQ_RISK_TRIGGER && state.position.risk <= CONFIG.MAX_RISK_EXIT) {
                const needed = calculateRecoveryQty(state.position.side, state.market.markPrice, state.position.entry, state.position.qty, CONFIG.TARGET_RECOVERY_ROI, CONFIG.LEVERAGE);
                let qty = Math.min(needed, state.position.qty * 1.5); 
                if(qty < minQtyLimit) qty = minQtyLimit;
                
                const safeQty = parseFloat(this.exchange.amountToPrecision(symbol, qty));
                const side = isLong ? 'buy' : 'sell'; 
                const limitPrice = isLong ? state.market.bid : state.market.ask;

                try {
                    if (state.bot.dcaOrderId) {
                        if (Math.abs(limitPrice - state.bot.dcaLastPrice) > (state.market.price * 0.0005)) {
                            await this.exchange.cancelOrder(state.bot.dcaOrderId, symbol).catch(()=>{});
                            state.bot.dcaOrderId = null;
                        }
                    }
                    if (!state.bot.dcaOrderId) {
                        console.log(`[${this.id}] üõ°Ô∏è ${coin} DCA (Risk: ${state.position.risk.toFixed(1)}%)`);
                        const order = await this.exchange.createOrder(symbol, 'limit', side, safeQty, limitPrice);
                        state.bot.dcaOrderId = order.id; state.bot.dcaLastPrice = limitPrice; state.bot.status = 'DEFENDED';
                    }
                } catch(e) { console.error(`[${this.id}] DCA Error:`, e.message); state.bot.dcaOrderId = null; }

            } else {
                if (state.bot.dcaOrderId) {
                    await this.exchange.cancelOrder(state.bot.dcaOrderId, symbol).catch(()=>{});
                    state.bot.dcaOrderId = null; state.bot.dcaLastPrice = 0;
                }
            }
        }
    }
}

// ================= INITIALIZATION =================
const accInstances = [];
const envFiles = fs.readdirSync(process.cwd()).filter(fn => fn.startsWith('.env') && !fn.endsWith('example'));
if (envFiles.length === 0) { console.error("‚ùå No .env files found!"); process.exit(1); }
envFiles.forEach((filename) => {
    const id = filename.split('.')[2] || 'Main';
    const creds = parseEnvFile(filename);
    if(creds.key && creds.secret) accInstances.push(new TradingAccount(id.toUpperCase(), filename, creds));
});

// ================= SERVER =================
const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: "*" } });

app.post('/close-all', async (req, res) => {
    console.log("\nüõë MANUAL CLOSE COMMAND RECEIVED üõë");
    await Promise.all(accInstances.map(a => a.closeAllPositions()));
    res.json({ success: true, message: "Close command sent to all accounts." });
});

async function mainLoop() {
    try {
        await Promise.all(accInstances.map(acc => acc.update()));
        
        let tLongs = 0, tShorts = 0;
        accInstances.forEach(acc => {
            Object.values(acc.data.coins).forEach(c => {
                if (c.position.qty > 0) {
                    if (c.position.side === 'long') tLongs++;
                    else if (c.position.side === 'short') tShorts++;
                }
            });
        });
        GLOBAL_OPEN_LONGS = tLongs;
        GLOBAL_OPEN_SHORTS = tShorts;
        
        const timeRemaining = GLOBAL_NEXT_AUTO_CLOSE - Date.now();

        if (timeRemaining <= 0) {
            console.log("\n‚è∞ 14-MINUTE TIMER EXPIRED: Scanning for Negative ROI Position...");
            
            let worstPos = null;
            let worstRoi = -0.5; 
            let targetAcc = null;

            accInstances.forEach(acc => {
                Object.values(acc.data.coins).forEach(coin => {
                    if (coin.position.qty > 0 && coin.position.roi < worstRoi) {
                        worstRoi = coin.position.roi;
                        worstPos = coin;
                        targetAcc = acc;
                    }
                });
            });

            if (worstPos && targetAcc) {
                console.log(`üíÄ SACRIFICING: ${targetAcc.id} - ${worstPos.symbol} (ROI: ${worstRoi.toFixed(2)}%)`);
                try {
                    await targetAcc.exchange.cancelAllOrders(worstPos.symbol).catch(() => {});
                    const side = worstPos.position.side === 'long' ? 'sell' : 'buy';
                    await targetAcc.exchange.createOrder(worstPos.symbol, 'market', side, worstPos.position.qty);
                    console.log(`‚úÖ SACRIFICE COMPLETE: ${worstPos.symbol}`);
                    worstPos.bot.status = 'IDLE';
                    worstPos.bot.retryUntil = Date.now() + 2000; 
                } catch(e) { console.error("‚ùå Sacrifice Failed:", e.message); }
            } else {
                console.log("‚ú® No positions require sacrifice.");
            }
            GLOBAL_NEXT_AUTO_CLOSE = Date.now() + CONFIG.PANIC_COOLDOWN_MS;
        }

        const payload = {
            globalPanic: GLOBAL_NEXT_AUTO_CLOSE,
            globalStats: { longs: GLOBAL_OPEN_LONGS, shorts: GLOBAL_OPEN_SHORTS },
            accounts: accInstances.map(a => ({ id: a.id, name: a.name, ...a.data }))
        };
        io.emit('update', payload);
    } catch (e) { console.error("‚ùå MAIN LOOP ERROR:", e.message); }
    setTimeout(mainLoop, CONFIG.POLL_RATE);
}

process.on('uncaughtException', (err) => {
    console.error('üî• UNCAUGHT EXCEPTION:', err);
});

// ================= DASHBOARD HTML =================
const DASHBOARD_HTML = `
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>‚ö° Bot Dashboard</title>
<script src="/socket.io/socket.io.js"></script>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@500;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
<style>
    :root { --bg: #f5f7fa; --card: #ffffff; --text-primary: #1f2937; --text-secondary: #6b7280; --green: #059669; --red: #dc2626; --orange: #d97706; --border: #e5e7eb; --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1); }
    body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text-primary); padding: 24px; font-size: 13px; margin: 0; }
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(420px, 1fr)); gap: 24px; }
    .card { background: var(--card); border-radius: 12px; padding: 24px; border: 1px solid var(--border); box-shadow: var(--shadow); display: flex; flex-direction: column; }
    .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 12px; border-bottom: 1px solid var(--border); }
    .title { font-weight: 700; color: var(--text-primary); font-size: 16px; }
    .tick { font-family: 'JetBrains Mono'; font-size: 11px; color: var(--text-secondary); background: #f3f4f6; padding: 2px 6px; border-radius: 4px; }
    .stat-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px; }
    .stat-label { color: var(--text-secondary); font-weight: 500; }
    .val { font-family: 'JetBrains Mono', monospace; font-weight: 700; }
    .green { color: var(--green); } .red { color: var(--red); }
    .history-container { margin-top: 20px; border-top: 1px solid var(--border); padding-top: 16px; max-height: 280px; overflow-y: auto; }
    table { width: 100%; border-collapse: collapse; font-family: 'Inter', sans-serif; font-size: 12px; }
    th { text-align: left; color: var(--text-secondary); font-weight: 600; padding: 8px 4px; border-bottom: 1px solid var(--border); position: sticky; top: 0; background: var(--card); }
    td { padding: 10px 4px; border-bottom: 1px solid var(--border); vertical-align: middle; }
    .td-sym { font-weight: 600; color: var(--text-primary); } 
    .td-pnl-val { font-family: 'JetBrains Mono'; font-size: 12px; font-weight: 600; } 
    .td-time { color: var(--text-secondary); font-size: 11px; line-height: 1.2; }
    .nav { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; background: var(--card); padding: 16px 24px; border-radius: 12px; border: 1px solid var(--border); box-shadow: var(--shadow); }
    .nav h2 { margin: 0; font-size: 18px; color: var(--text-primary); }
    .btn-panic { background: #fee2e2; color: #b91c1c; border: 1px solid #fecaca; padding: 10px 20px; font-weight: 600; border-radius: 6px; cursor: pointer; transition: all 0.2s; font-family: 'Inter', sans-serif; font-size: 13px; }
    .btn-panic:hover { background: #fecaca; color: #991b1b; }
    .global-alert { background: #fee2e2; border: 1px solid #fecaca; color: #b91c1c; padding: 12px; border-radius: 8px; margin-bottom: 20px; font-weight: 700; text-align: center; }
</style>
</head><body>
<div id="global-alert-box"></div>
<div class="nav">
    <div style="display:flex; flex-direction:column;">
        <h2>‚ö° Ironclad Bot v2.4 <span style="font-size:14px; font-weight:400; color:var(--text-secondary); margin-left:8px;">| ${COIN_LIST.length} Active Coins</span></h2>
        <div id="perf-stats" style="font-family:'JetBrains Mono'; font-weight:700; font-size:13px; margin-top:5px; color:var(--text-secondary);">Connecting...</div>
    </div>
    <button class="btn-panic" onclick="closeAllPositions()">üö® CLOSE ALL POSITIONS</button>
</div>
<div class="grid" id="app"></div>
<script>
    const socket = io();
    function fmtPrice(p) { if (p < 0.0001) return p.toFixed(9); if (p < 0.01) return p.toFixed(7); if (p < 1) return p.toFixed(5); return p.toFixed(3); }
    function fmtDate(ms) { if(!ms) return '-'; return new Date(ms).toISOString().replace('T', ' ').slice(0, 19); }
    
    function closeAllPositions() {
        if(confirm("‚ö†Ô∏è CONFIRM CLOSE ALL? ‚ö†Ô∏è\\n\\nThis will market-close ALL positions immediately.")) {
            fetch('/close-all', { method: 'POST' }).then(r=>r.json()).then(d=>alert("‚úÖ "+d.message)).catch(e=>alert("‚ùå Error"));
        }
    }
    socket.on('update', (payload) => {
        const { globalPanic, globalStats, accounts } = payload;
        const timeLeft = Math.max(0, globalPanic - Date.now());
        const mins = Math.ceil(timeLeft / 60000);
        document.getElementById('global-alert-box').innerHTML = mins <= 14 ? \`<div class="global-alert">üî™ SCHEDULED SACRIFICE: Next Cut in \${mins} minutes</div>\` : '';
        
        let wins30m = 0, losses30m = 0;
        const timeLimit = Date.now() - (30 * 60 * 1000); 
        accounts.forEach(acc => { acc.history.forEach(h => { if (h.closeTime > timeLimit) { if (h.pnl > 0) wins30m++; else losses30m++; }}); });
        
        document.getElementById('perf-stats').innerHTML = \`<span style="color:var(--green)">LONG: \${globalStats.longs}</span> | <span style="color:var(--red)">SHORT: \${globalStats.shorts}</span> &nbsp;[30m: <span style="color:var(--green)">\${wins30m}W</span> <span style="color:var(--red)">\${losses30m}L</span>]\`;

        document.getElementById('app').innerHTML = accounts.map(acc => {
            let rows = acc.history.map(h => {
                const pnlColor = h.pnl >= 0 ? 'green' : 'red';
                return \`<tr><td><div class="td-sym">\${h.symbol}</div></td><td><div style="font-weight:600">\${h.totalSize}</div></td><td><div>\${fmtPrice(h.openPrice)}</div></td><td class="td-pnl-val"><div class="\${pnlColor}">\${h.pnl.toFixed(4)}</div></td><td class="td-pnl-val \${pnlColor}">\${h.roi.toFixed(2)}%</td><td class="td-time"><div>\${fmtDate(h.closeTime)}</div></td></tr>\`;
            }).join('');
            if(rows === '') rows = '<tr><td colspan="6" style="text-align:center; padding:30px; color:var(--text-secondary);">No closed trades yet</td></tr>';
            
            return \`<div class="card"><div class="header"><div class="title">\${acc.id}</div><div class="tick">‚ö° \${acc.tickDuration}ms</div></div>
                <div class="stat-row"><span class="stat-label">Balance</span> <span class="val">\${parseFloat(acc.wallet.balance).toFixed(2)}</span></div>
                <div class="stat-row"><span class="stat-label">Total PnL</span> <span class="val \${acc.wallet.totalUpnl>=0?'green':'red'}">\${acc.wallet.totalUpnl.toFixed(4)}</span></div>
                <div class="stat-row"><span class="stat-label">Max Risk</span> <span class="val" style="color:\${acc.maxRisk>50?'var(--red)':'inherit'}">\${acc.maxRisk.toFixed(1)}%</span></div>
                <div class="history-container"><table><thead><tr><th>Coin</th><th>Size</th><th>Entry</th><th>PnL</th><th>ROI</th><th>Time</th></tr></thead><tbody>\${rows}</tbody></table></div>
            </div>\`;
        }).join('');
    });
</script></body></html>`;

app.get('/', (req, res) => res.send(DASHBOARD_HTML));

server.listen(PORT, async () => {
    console.log(`\n=================================================`);
    console.log(`üöÄ BOT STARTED ON PORT ${PORT}`);
    console.log(`=================================================\n`);
    await Promise.all(accInstances.map(a => a.init()));
    console.log('\n‚úÖ Loop Started...');
    mainLoop();
});

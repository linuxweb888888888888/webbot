/**
 * PHEMEX ULTIMATE - HYBRID EDITION (v46.42 - PROFIT PROTECTION RESTORED)
 * SPECIAL EDITION: HITBTC CROSS FUTURES
 * 
 * CHANGES v46.42:
 * 1. BOT: Restored "Profit Protection" Logic per user request.
 *    - Formula: If |Unrealized Loss| < (Total Realized PnL / 5) AND ROI < -10%.
 *    - Logic: Checks if the absolute loss is SMALLER than the safety buffer.
 *    - Trims small losers to protect gains, keeps large losers for DCA.
 * 2. BOT: Kept "Single Coin Margin Reserve" Logic.
 */

const express = require('express');
const http = require('http');
const https = require('https'); 
const socketIo = require('socket.io');
const ccxt = require('ccxt');
const session = require('express-session');
const bodyParser = require('body-parser');
const crypto = require('crypto');
const mongoose = require('mongoose'); 

// ==========================================
// 1. CONFIGURATION
// ==========================================
const PORT = process.env.PORT || 3000;
const SESSION_SECRET = 'hitbtc-ultimate-secret-v45';

// ðŸ”´ MONGODB CONNECTION STRING
const MONGO_URI = 'mongodb+srv://web88888888888888_db_user:ZETrZHXzaxoekjkm@cluster0.vsmsbjh.mongodb.net/?appName=Cluster0';

const NEWS_API_KEY = '5b69e4d348ad436ca832910872c7d663'; 
const STARTING_BALANCE = 1000.00; 

// CURRENCY RATES (Base: USDT)
const CURRENCIES = {
    'USD': { rate: 1.0, symbol: '$' },
    'GBP': { rate: 0.79, symbol: 'Â£' },
    'EUR': { rate: 0.93, symbol: 'â‚¬' },
    'ZAR': { rate: 19.0, symbol: 'R' }
};

// TRADING SETTINGS
const MAINTENANCE_MARGIN_RATE = 0.005; 
const TAKER_FEE_RATE = 0.0006;         
const SLIPPAGE_RATE = 0.0002;          

const args = process.argv.slice(2);
const coinArg = args.find(a => a.startsWith('--coin='));
let customPairs = [];

if (coinArg) {
    const rawValue = coinArg.split('=')[1];
    if (rawValue) {
        const rawCoins = rawValue.split(/[\s,]+/).filter(c => c.trim().length > 0);
        customPairs = rawCoins.map(c => {
            let pair = c.trim();
            if (!pair.includes('/') && !pair.includes(':')) {
                pair = `${pair.toUpperCase()}/USDT:USDT`;
            }
            return pair;
        });
    }
}

// CCXT Unified Symbols for HitBTC Derivatives
const DEFAULT_PAIRS = [
    'BTC/USDT:USDT', 'ETH/USDT:USDT', 'SOL/USDT:USDT', 'XRP/USDT:USDT', 
    'LINK/USDT:USDT', 'DOGE/USDT:USDT', 'PEPE/USDT:USDT', 'SHIB/USDT:USDT', 
    'ADA/USDT:USDT', 'AVAX/USDT:USDT', 'EOS/USDT:USDT', 'LTC/USDT:USDT', 'ATOM/USDT:USDT'
];

const SUPPORTED_PAIRS = customPairs.length > 0 ? customPairs : DEFAULT_PAIRS;

// RAW GLOBAL TICKER STORE (Direct from CCXT)
let GLOBAL_TICKERS = {};

// GLOBAL NEWS CACHE
let newsCache = [];
let lastNewsFetch = 0;

// ==========================================
// 1.1 CLOUD PERSISTENCE LAYER (MongoDB)
// ==========================================
let users = [];
let analytics = {
    pageViews: [],
    totalViews: 0, 
    clicks: [],
    registrations: 0,
    botStarts: 0
};

// Mongoose Schemas
const UserSchema = new mongoose.Schema({
    id: { type: String, unique: true },
    username: String,
    password: String,
    currency: String,
    mode: String,
    realKeys: Object,
    bot: Object,
    virtual: Object,
    real: Object 
}, { strict: false });

const AnalyticsSchema = new mongoose.Schema({
    id: { type: String, default: 'global_stats' },
    data: Object
}, { strict: false });

const UserModel = mongoose.model('User', UserSchema);
const AnalyticsModel = mongoose.model('Analytics', AnalyticsSchema);

async function loadDatabase() {
    try {
        const cloudUsers = await UserModel.find({});
        if (cloudUsers.length > 0) {
            users = cloudUsers.map(u => {
                let userObj = u.toObject();
                if (!userObj.virtual) userObj.virtual = {};
                if (!userObj.virtual.positions) userObj.virtual.positions = {};
                if (!userObj.virtual.closedTrades) userObj.virtual.closedTrades = [];
                
                if (!userObj.real) userObj.real = {};
                if (!userObj.real.closedTrades) userObj.real.closedTrades = [];

                userObj.client = null;
                userObj.realClient = null;
                return userObj;
            });
            console.log(`ðŸ“‚ DB LOADED: ${users.length} users retrieved.`);
        }
        const cloudAnalytics = await AnalyticsModel.findOne({ id: 'global_stats' });
        if (cloudAnalytics && cloudAnalytics.data) {
            analytics = cloudAnalytics.data;
            if(!analytics.totalViews) analytics.totalViews = analytics.pageViews.length;
        }
    } catch (e) {
        console.log("âš ï¸ DB Load Error:", e.message);
    }
}

async function saveDatabase() {
    try {
        for (const user of users) {
            const { client, realClient, _id, ...cleanUser } = user;
            await UserModel.findOneAndUpdate({ id: user.id }, cleanUser, { upsert: true });
        }
        await AnalyticsModel.findOneAndUpdate({ id: 'global_stats' }, { data: analytics }, { upsert: true });
    } catch (e) {
        console.error("âŒ Cloud Save Error:", e.message);
    }
}

// Global Public Client (HitBTC)
const publicClient = new ccxt.hitbtc({ 
    enableRateLimit: true,
    timeout: 60000, 
    options: { defaultType: 'swap' } 
});

// ==========================================
// 2. REAL CLIENT WRAPPER (HitBTC ADAPTER - MANUAL FETCH)
// ==========================================
class RealClientWrapper {
    constructor(apiKey, secret) {
        this.apiKey = apiKey; 
        this.secret = secret; 
        this.parentUser = null; 
        this.ccxt = new ccxt.hitbtc({
            apiKey: apiKey,
            secret: secret,
            enableRateLimit: true,
            timeout: 60000,
            options: { defaultType: 'swap' } 
        });
        this.maxMarginUsed = 0; 
        this.marketsLoaded = false;
    }

    getRawSymbol(botSymbol) {
        if (!botSymbol) return '';
        return botSymbol.replace(':USDT', '').replace('/', '');
    }

    async rawRequest(path) {
        return new Promise((resolve, reject) => {
            const auth = 'Basic ' + Buffer.from(this.apiKey + ':' + this.secret).toString('base64');
            const options = {
                hostname: 'api.hitbtc.com',
                path: path,
                method: 'GET',
                headers: {
                    'Authorization': auth,
                    'Content-Type': 'application/json',
                    'User-Agent': 'NodeJS/1.0'
                }
            };
            const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                    try {
                        const parsed = JSON.parse(data);
                        resolve(parsed);
                    } catch (e) {
                        resolve([]); 
                    }
                });
            });

            req.on('error', (e) => {
                resolve([]);
            });
            req.end();
        });
    }

    async rawDeleteRequest(path) {
        return new Promise((resolve, reject) => {
            const auth = 'Basic ' + Buffer.from(this.apiKey + ':' + this.secret).toString('base64');
            const options = {
                hostname: 'api.hitbtc.com',
                path: path,
                method: 'DELETE',
                headers: {
                    'Authorization': auth,
                    'Content-Type': 'application/json',
                    'User-Agent': 'NodeJS/1.0'
                }
            };

            const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                    try {
                        if(!data) return resolve({ success: true });
                        const parsed = JSON.parse(data);
                        resolve(parsed);
                    } catch (e) {
                        resolve({ success: true });
                    }
                });
            });

            req.on('error', (e) => {
                resolve({});
            });
            req.end();
        });
    }

    async rawPostRequest(path, bodyStr) {
        return new Promise((resolve, reject) => {
            const auth = 'Basic ' + Buffer.from(this.apiKey + ':' + this.secret).toString('base64');
            const options = {
                hostname: 'api.hitbtc.com',
                path: path,
                method: 'POST',
                headers: {
                    'Authorization': auth,
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Content-Length': Buffer.byteLength(bodyStr),
                    'User-Agent': 'NodeJS/1.0'
                }
            };

            const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                    try {
                        const parsed = JSON.parse(data);
                        resolve(parsed);
                    } catch (e) {
                        resolve({}); 
                    }
                });
            });

            req.on('error', (e) => {
                resolve({});
            });
            
            req.write(bodyStr);
            req.end();
        });
    }

    async ensureMarkets() {
        if (!this.marketsLoaded || Object.keys(this.ccxt.markets).length === 0) {
            try {
                await this.ccxt.loadMarkets();
                this.marketsLoaded = true;
            } catch (e) {
                await new Promise(r => setTimeout(r, 2000));
                try { await this.ccxt.loadMarkets(); this.marketsLoaded = true; } catch(err){}
            }
        }
    }

    async loadMarkets() { 
        await this.ccxt.loadMarkets(); 
        this.marketsLoaded = true;
    }

    market(symbol) { 
        if(!this.ccxt.markets || !this.ccxt.markets[symbol]) return { limits: { amount: { min: 0.001 } } };
        return this.ccxt.market(symbol); 
    }
    
    async fetchBalance() {
        try {
            const data = await this.rawRequest('/api/3/futures/account');
            let free = 0; let total = 0; let used = 0;

            if (Array.isArray(data)) {
                const crossAccount = data.find(acc => acc.type && acc.type.toLowerCase() === 'cross');
                if (crossAccount && crossAccount.currencies && Array.isArray(crossAccount.currencies)) {
                    const usdt = crossAccount.currencies.find(c => c.code === 'USDT');
                    if (usdt) {
                        const marginBalance = parseFloat(usdt.margin_balance || 0);
                        const reservedOrders = parseFloat(usdt.reserved_orders || 0);
                        const reservedPos = parseFloat(usdt.reserved_positions || 0);
                        total = marginBalance; 
                        used = reservedOrders + reservedPos;
                        free = Math.max(0, total - used); 
                    }
                }
            }
            if (used > this.maxMarginUsed) this.maxMarginUsed = used;
            return { 
                USDT: { free, used, total },
                free: { USDT: free },
                total: { USDT: total },
                used: { USDT: used }
            };
        } catch (e) {
            return { USDT: { free: 0, used: 0, total: 0 }, free: { USDT: 0 }, total: { USDT: 0 }, used: { USDT: 0 } };
        }
    }

    async fetchPositions(symbols = undefined) {
        try {
            const data = await this.rawRequest('/api/3/futures/account');
            if (!Array.isArray(data)) return [];

            const crossAccount = data.find(acc => acc.type && acc.type.toLowerCase() === 'cross');
            if (!crossAccount || !crossAccount.positions || !Array.isArray(crossAccount.positions)) {
                return [];
            }

            const mapped = crossAccount.positions.map(p => {
                const rawSize = parseFloat(p.quantity || 0);
                const size = Math.abs(rawSize);
                
                if(size === 0) return null;

                const rawSymbol = p.symbol; 
                const rawBase = rawSymbol.replace('_PERP', '').replace(/[^A-Z0-9]/g, ''); 
                let formattedSymbol = rawBase;
                
                const match = SUPPORTED_PAIRS.find(s => {
                    const sClean = s.replace(/[^A-Z0-9]/g, '').replace(/USDT/g, ''); 
                    const pClean = rawBase.replace(/USDT/g, ''); 
                    return sClean === pClean;
                });
                
                if(match) formattedSymbol = match;

                const entry = parseFloat(p.price_entry || 0);
                const lev = parseFloat(p.leverage || 10);
                let side = rawSize >= 0 ? 'long' : 'short';

                let ticker = Object.values(GLOBAL_TICKERS).find(t => t.id === rawSymbol);
                if(!ticker) {
                    ticker = Object.values(GLOBAL_TICKERS).find(t => t.symbol.replace(/[^A-Z0-9]/g, '').includes(rawBase));
                }

                let currentBid = entry; let currentAsk = entry;
                if (ticker) {
                    currentBid = ticker.bid || ticker.last || entry;
                    currentAsk = ticker.ask || ticker.last || entry;
                }

                let uPnL = 0;
                if (entry > 0) {
                    if (side === 'long') uPnL = (currentBid - entry) * size;
                    else uPnL = (entry - currentAsk) * size;
                } 

                const initialMargin = (size * entry) / lev;
                let calculatedRoi = 0;
                if (initialMargin > 0) calculatedRoi = (uPnL / initialMargin) * 100;

                let finalLiq = parseFloat(p.price_liquidation || 0);
                if (finalLiq === 0 && entry > 0) {
                     const mm = MAINTENANCE_MARGIN_RATE;
                     if (side === 'long') finalLiq = entry * (1 - (1/lev) + mm);
                     else finalLiq = entry * (1 + (1/lev) - mm);
                }

                return {
                    symbol: formattedSymbol,
                    contracts: size,
                    side: side, 
                    entryPrice: entry,
                    leverage: lev,
                    unrealizedPnl: uPnL, 
                    roi: calculatedRoi,  
                    liquidationPrice: finalLiq, 
                    info: p
                };
            }).filter(p => p !== null);

            if(symbols && Array.isArray(symbols)) {
                return mapped.filter(p => symbols.includes(p.symbol));
            }
            return mapped;

        } catch(e) {
            return [];
        }
    }

    async fetchTicker(symbol) { 
        await this.ensureMarkets();
        return await this.ccxt.fetchTicker(symbol); 
    }
    
    async fetchTickers(symbols) {
        await this.ensureMarkets();
        return await this.ccxt.fetchTickers(symbols);
    }
    
    // --- UPDATED CREATE ORDER FOR HITBTC SYMBOLS ---
    async createOrder(symbol, type, side, amount, price = undefined) {
        await this.ensureMarkets();
        if (type === 'market') price = undefined; 
        else if (type === 'limit' && !price) {
            type = 'market';
            price = undefined;
        }
        const params = { type: 'swap', marginMode: 'cross' };
        
        try {
            // Attempt standard CCXT order
            return await this.ccxt.createOrder(symbol, type, side, amount, price, params);
        } catch(e) {
            console.log(`[HitBTC] Standard CCXT failed for ${symbol}: ${e.message}. Attempting PERP fallback...`);
            
            // Fallback: Construct raw symbol with _PERP
            let rawSymbol = this.getRawSymbol(symbol);
            if(rawSymbol && !rawSymbol.endsWith('_PERP')) {
                rawSymbol += '_PERP';
            }
            
            // Retry with explicit _PERP symbol
            return await this.ccxt.createOrder(rawSymbol, type, side, amount, price, params);
        }
    }

    async setLeverage(lev, symbol) {
        await this.ensureMarkets();
        let requestedLev = parseInt(lev);
        const market = this.market(symbol);
        if (market && market.limits && market.limits.leverage && market.limits.leverage.max) {
            const maxLev = parseInt(market.limits.leverage.max);
            if (requestedLev > maxLev) {
                requestedLev = maxLev;
            }
        }
        let rawSymbol = this.getRawSymbol(symbol);
        if(rawSymbol && !rawSymbol.endsWith('_PERP')) {
            rawSymbol += '_PERP';
        }
        const body = `symbol=${rawSymbol}&leverage=${requestedLev}&margin_mode=cross`;
        try {
            await this.rawPostRequest('/api/3/futures/position/leverage', body);
        } catch(e) { console.log("[HitBTC] Set Lev Error:", e.message); }
        return requestedLev;
    }

    async setMarginMode(mode, symbol) { return; }

    async closePosition(symbol) {
        let rawSymbol = this.getRawSymbol(symbol);
        if(rawSymbol && !rawSymbol.endsWith('_PERP')) {
            rawSymbol += '_PERP';
        }
        return await this.rawDeleteRequest(`/api/3/futures/position/cross/${rawSymbol}`);
    }

    async closeAllPositions() {
        return await this.rawDeleteRequest('/api/3/futures/position');
    }

    async fetchOpenOrders(symbol) { 
        await this.ensureMarkets();
        try { 
            const params = { type: 'swap', marginMode: 'cross' };
            return await this.ccxt.fetchOpenOrders(symbol, undefined, undefined, params); 
        } catch(e) { return []; }
    }
    
    async fetchMyTrades(symbol) { return []; }
    
    async cancelOrder(id, symbol) { 
        await this.ensureMarkets();
        return await this.ccxt.cancelOrder(id, symbol); 
    }
    async checkLiquidations() { return; } 
}

// ==========================================
// 3. VIRTUAL CLIENT SIMULATOR
// ==========================================
class VirtualClient {
    constructor(user) {
        this.user = user;
        this.id = 'hitbtc-sim'; 
        if(!this.user.virtual) this.user.virtual = { balance: 0, positions: {}, closedTrades: [], trades: [] };
        if(!this.user.virtual.positions) this.user.virtual.positions = {};
    }
    async loadMarkets() { return true; }
    async ensureMarkets() { return true; }
    
    market(symbol) { 
        if (publicClient.markets && publicClient.markets[symbol]) {
            return publicClient.markets[symbol];
        }
        return { limits: { amount: { min: 0.001 } }, id: symbol }; 
    }
    
    amountToPrecision(symbol, amount) { return parseFloat(amount).toFixed(4); }
    priceToPrecision(symbol, price) { return parseFloat(price).toString(); }

    async fetchTicker(symbol) {
        const clean = symbol.split(':')[0].replace(/[^A-Z0-9]/g, '');
        const ticker = Object.values(GLOBAL_TICKERS).find(t => t.symbol.replace(/[^A-Z0-9]/g, '').includes(clean));
        const price = ticker ? ticker.last : 0;
        return { last: price, info: { markPrice: price } };
    }
    
    async fetchTickers(symbols) { return {}; } 

    async fetchBalance() {
        const total = this.user.virtual.balance;
        let used = 0;
        
        for (const sym in this.user.virtual.positions) {
            const pos = this.user.virtual.positions[sym];
            if (pos && pos.size > 0) {
                const leverage = pos.leverage || 10;
                const positionValue = pos.size * pos.entryPrice;
                const marginRequired = positionValue / leverage;
                used += marginRequired;
            }
        }

        if (used > (this.user.virtual.maxMarginUsed || 0)) {
            this.user.virtual.maxMarginUsed = used;
        }
        
        const free = Math.max(0, total - used);

        return { 
            USDT: { free: free, used: used, total: total }, 
            free: { USDT: free }, 
            total: { USDT: total },
            used: { USDT: used }
        };
    }

    getLiquidationPrice(entry, side, leverage) {
        const mm = MAINTENANCE_MARGIN_RATE; 
        if (side === 'long') return entry * (1 - (1 / leverage) + mm);
        else return entry * (1 + (1 / leverage) - mm);
    }

    async checkLiquidations() {
        const targets = Object.keys(this.user.virtual.positions);
        for (const sym of targets) {
            const pos = this.user.virtual.positions[sym];
            if (!pos) continue;

            const clean = sym.split(':')[0].replace(/[^A-Z0-9]/g, '');
            const ticker = Object.values(GLOBAL_TICKERS).find(t => t.symbol.replace(/[^A-Z0-9]/g, '').includes(clean));
            const currentPrice = ticker ? ticker.last : 0;
            
            if (currentPrice === 0) continue;

            const liqPrice = this.getLiquidationPrice(pos.entryPrice, pos.side, pos.leverage);
            
            let liquidated = false;
            if (pos.side === 'long' && currentPrice <= liqPrice) liquidated = true;
            if (pos.side === 'short' && currentPrice >= liqPrice) liquidated = true;

            if (liquidated) {
                const marginLost = (pos.size * pos.entryPrice) / pos.leverage;
                this.user.virtual.balance -= marginLost;
                if(!this.user.virtual.closedTrades) this.user.virtual.closedTrades = [];
                this.user.virtual.closedTrades.unshift({
                    timestamp: Date.now(),
                    symbol: sym,
                    side: pos.side,
                    qty: pos.size,
                    entry: pos.entryPrice,
                    close: currentPrice,
                    pnl: -marginLost,
                    roi: -100.00,
                    status: 'LIQUIDATED'
                });
                if(this.user.virtual.closedTrades.length > 50) this.user.virtual.closedTrades.pop();
                delete this.user.virtual.positions[sym];
                saveDatabase(); 
            }
        }
    }

    async fetchPositions(symbols = undefined) {
        const result = [];
        const targets = symbols || Object.keys(this.user.virtual.positions);
        
        for (const sym of targets) {
            const pos = this.user.virtual.positions[sym];
            if (pos && Math.abs(pos.size) > 0) {
                
                const clean = sym.split(':')[0].replace(/[^A-Z0-9]/g, '');
                const ticker = Object.values(GLOBAL_TICKERS).find(t => t.symbol.replace(/[^A-Z0-9]/g, '').includes(clean));
                
                const currentPrice = ticker ? ticker.last : pos.entryPrice;
                let upnl = 0;
                
                if(pos.side === 'long') upnl = (currentPrice - pos.entryPrice) * pos.size;
                else upnl = (pos.entryPrice - currentPrice) * pos.size;

                const margin = (pos.size * pos.entryPrice) / pos.leverage;
                const roi = margin > 0 ? (upnl / margin) * 100 : 0;
                const liqPrice = this.getLiquidationPrice(pos.entryPrice, pos.side, pos.leverage);

                result.push({
                    symbol: sym,
                    contracts: Math.abs(pos.size),
                    side: pos.side,
                    entryPrice: pos.entryPrice,
                    leverage: pos.leverage, 
                    unrealizedPnl: upnl,
                    roi: roi, 
                    liquidationPrice: liqPrice, 
                    info: {} 
                });
            }
        }
        return result;
    }

    async setLeverage(lev, symbol) {
        let requestedLev = parseInt(lev);
        const market = this.market(symbol);
        if (market && market.limits && market.limits.leverage && market.limits.leverage.max) {
            const maxLev = parseInt(market.limits.leverage.max);
            if (requestedLev > maxLev) {
                requestedLev = maxLev;
            }
        }

        if (!this.user.virtual.positions[symbol]) {
            this.user.virtual.positions[symbol] = { size: 0, entryPrice: 0, side: 'long', leverage: requestedLev };
        } else {
            this.user.virtual.positions[symbol].leverage = requestedLev;
        }
        return requestedLev;
    }

    async setMarginMode(mode, symbol) {
        return true; 
    }

    async createOrder(symbol, type, side, amount, price = undefined) {
        const qty = parseFloat(amount);
        const clean = symbol.split(':')[0].replace(/[^A-Z0-9]/g, '');
        const ticker = Object.values(GLOBAL_TICKERS).find(t => t.symbol.replace(/[^A-Z0-9]/g, '').includes(clean));
        
        let currentPrice = (type === 'limit' && price) ? parseFloat(price) : (ticker ? ticker.last : 0);
        
        if (currentPrice === 0) throw new Error("Market price unavailable");

        if (type === 'market') {
            const slippage = currentPrice * SLIPPAGE_RATE; 
            if (side === 'buy') currentPrice += (Math.random() * slippage); 
            else currentPrice -= (Math.random() * slippage); 
        }

        let vPos = this.user.virtual.positions[symbol];
        if(!vPos) {
            await this.setLeverage(10, symbol);
            vPos = this.user.virtual.positions[symbol];
        }

        const signedQty = side === 'buy' ? qty : -qty;
        let internalSize = (vPos.side === 'long' ? vPos.size : -vPos.size);
        const isIncreasing = (side === 'buy' && internalSize >= 0) || (side === 'sell' && internalSize <= 0);

        if (isIncreasing) {
            const leverage = vPos.leverage || 10;
            const requiredMargin = (qty * currentPrice) / leverage;
            const balance = await this.fetchBalance();
            if (balance.free.USDT < requiredMargin) {
                throw new Error(`Insufficient Free Margin. Need $${requiredMargin.toFixed(2)}, Have $${balance.free.USDT.toFixed(2)}`);
            }
        }

        const tradeValue = qty * currentPrice;
        const fee = tradeValue * TAKER_FEE_RATE;
        this.user.virtual.balance -= fee;

        if (isIncreasing) {
            const totalCost = (Math.abs(internalSize) * vPos.entryPrice) + (qty * currentPrice);
            const totalQty = Math.abs(internalSize) + qty;
            vPos.entryPrice = totalCost / totalQty;
            internalSize += signedQty;
        } 
        else {
            const amountClosed = Math.min(Math.abs(internalSize), qty);
            let pnl = 0;
            if (internalSize > 0) pnl = (currentPrice - vPos.entryPrice) * amountClosed;
            else pnl = (vPos.entryPrice - currentPrice) * amountClosed;
            
            this.user.virtual.balance += pnl;

            if (amountClosed > 0) {
                const margin = (amountClosed * vPos.entryPrice) / vPos.leverage;
                const roi = margin > 0 ? (pnl / margin) * 100 : 0;
                if(!this.user.virtual.closedTrades) this.user.virtual.closedTrades = [];
                this.user.virtual.closedTrades.unshift({
                    timestamp: Date.now(),
                    symbol: symbol,
                    side: vPos.side, 
                    qty: amountClosed,
                    entry: vPos.entryPrice,
                    close: currentPrice,
                    pnl: pnl,
                    roi: roi
                });
                if(this.user.virtual.closedTrades.length > 50) this.user.virtual.closedTrades.pop();
            }
            internalSize += signedQty;
            if ((side === 'sell' && internalSize < 0 && vPos.side === 'long') || 
                (side === 'buy' && internalSize > 0 && vPos.side === 'short')) {
                vPos.entryPrice = currentPrice;
            }
        }

        if (Math.abs(internalSize) < 0.00000001) internalSize = 0;
        
        vPos.size = Math.abs(internalSize);
        vPos.side = internalSize >= 0 ? 'long' : 'short';
        
        if (vPos.size === 0) delete this.user.virtual.positions[symbol];
        else this.user.virtual.positions[symbol] = vPos;

        if(!this.user.virtual.trades) this.user.virtual.trades = [];
        this.user.virtual.trades.push({
            id: crypto.randomBytes(4).toString('hex'), timestamp: Date.now(),
            symbol, side, price: currentPrice, amount: qty, cost: tradeValue
        });

        saveDatabase(); 
        return { id: 'virt_'+Date.now(), side, price: currentPrice, amount: qty };
    }

    async fetchOpenOrders(symbol) { return []; }
    async fetchMyTrades(symbol) { return (this.user.virtual.trades || []).filter(t => t.symbol === symbol); }
    async cancelOrder(id) { return true; }
}

// ==========================================
// 4. SERVER INIT & TRACKING
// ==========================================
const app = express();
const server = http.createServer(app);
const io = socketIo(server);

process.on('uncaughtException', (err) => { console.error('âŒ UNCAUGHT EXCEPTION:', err); });
process.on('unhandledRejection', (reason, promise) => { console.error('âŒ UNHANDLED REJECTION:', reason); });

app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());
app.use(session({ secret: SESSION_SECRET, resave: false, saveUninitialized: true }));

app.use((req, res, next) => {
    if(!req.url.startsWith('/socket') && !req.url.startsWith('/api') && !req.url.includes('.')) {
        const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress;
        const ua = req.headers['user-agent'] || 'Unknown';
        analytics.pageViews.push({ path: req.url, ip: ip, time: Date.now(), ua: ua });
        // Tracking logic update: Keep array limited but increment total indefinitely
        if(analytics.pageViews.length > 500) analytics.pageViews.shift();
        
        if(!analytics.totalViews) analytics.totalViews = 0;
        analytics.totalViews++;
    }
    next();
});

let currentPairIndex = 0;

(async () => {
    try { await publicClient.loadMarkets(); console.log(`ðŸ”¹ SYSTEM START: HitBTC Connected`); } catch(e) {}
})();

io.on('connection', (socket) => {
    socket.on('tracking_data', (data) => {});
    socket.on('user_click', (data) => {
        analytics.clicks.push({ ...data, time: Date.now(), socketId: socket.id });
        if(analytics.clicks.length > 200) analytics.clicks.shift();
    });
});

// --- UPDATED MAIN LOOP: GLOBAL TICKER UPDATE ---
setInterval(async () => {
    try {
        GLOBAL_TICKERS = await publicClient.fetchTickers(); 
        const activeSymbol = SUPPORTED_PAIRS[currentPairIndex];
        const book = await publicClient.fetchOrderBook(activeSymbol, 20);
        const ticker = GLOBAL_TICKERS[activeSymbol] || {};
        const livePrice = ticker.last || 0;
        let pct = 0;
        if(ticker.open) pct = ((livePrice - ticker.open) / ticker.open) * 100;

        io.emit(`market_${activeSymbol}`, { 
            symbol: activeSymbol, 
            price: livePrice, 
            mark: livePrice, 
            change: pct, 
            bids: book.bids, 
            asks: book.asks 
        });
        currentPairIndex = (currentPairIndex + 1) % SUPPORTED_PAIRS.length;

        for(let u of users) { 
            if(u.mode === 'virtual' && u.client) await u.client.checkLiquidations(); 
        }

    } catch (e) { 
        console.log("Loop Error:", e.message); 
    }
}, 2000); 

// ==========================================
// 5. BOT ENGINE (HYBRID)
// ==========================================
async function runBotLogic() {
    let dbUpdateNeeded = false;
    for (const user of users) {
        if (!user.bot.active || user.bot.coins.length === 0) continue;
        const config = user.bot;
        const triggerRoi = parseFloat(config.triggerRoi || -15);
        const recoveryRoi = parseFloat(config.recoveryRoi || -5);
        const profitRoi = parseFloat(config.profitRoi || 6);
        const multiplier = parseFloat(config.tradeMultiplier || 1); 
        const stopLossRoi = parseFloat(config.stopLossRoi || -50);
        
        // --- NEW: GRADUAL DCA SETTING ---
        const gradualDcaRoi = parseFloat(config.gradualDcaRoi || -999);

        // --- UPDATED: UNLIMITED DCA LEVELS ---
        const MAX_DCA_COUNT = 999999; 
        const userCurr = user.currency || 'USD';
        const rate = CURRENCIES[userCurr].rate;

        // Initialize Client for User
        const client = await getUserClient(user);
        await client.ensureMarkets(); 

        // === DYNAMIC MARGIN RESERVATION LOGIC ===
        // 1. Fetch Global State to find Highest Min Cost & Its Status
        // 2. Used to restrict entries if the heavy coin is closed.
        let allPositions = [];
        try {
            if(user.mode === 'real') {
                allPositions = await client.fetchPositions();
            } else {
                allPositions = await client.fetchPositions();
            }
        } catch(e) {}

        const balance = await client.fetchBalance();
        const freeUsdt = parseFloat(balance.free.USDT || 0);
        
        let highestMinCost = 0;
        let expensiveCoinSymbol = '';

        // Scan to find the single most expensive coin minimum (Highest Min Cost)
        for (const c of user.bot.coins) {
            const sym = c.symbol;
            const cleanSym = sym.replace(/[^A-Z0-9]/g, '');
            const t = Object.values(GLOBAL_TICKERS).find(t => t.symbol.replace(/[^A-Z0-9]/g, '').includes(cleanSym));
            const p = t ? t.last : 0;
            
            // Get Min Qty from Market
            let minQ = 0.001;
            try {
                const m = client.market(sym);
                if (m && m.limits && m.limits.amount && m.limits.amount.min) minQ = m.limits.amount.min;
            } catch(e) {}

            // Cost = (Price * MinQty) / Leverage
            const l = user.bot.leverage || 10; 
            if(p > 0) {
                const cost = (p * minQ) / l;
                if (cost > highestMinCost) {
                    highestMinCost = cost;
                    expensiveCoinSymbol = sym;
                }
            }
        }

        // Check if the expensive coin is currently OPEN
        const expensivePos = allPositions.find(p => p.symbol === expensiveCoinSymbol);
        const isExpensiveOpen = expensivePos && parseFloat(expensivePos.contracts) > 0;

        for (const target of config.coins) {
            const symbol = target.symbol;
            const forcedSide = target.side;
            try {
                const clean = symbol.replace(/[^A-Z0-9]/g, '');
                const ticker = Object.values(GLOBAL_TICKERS).find(t => t.symbol.replace(/[^A-Z0-9]/g, '').includes(clean));
                let currentPrice = ticker ? ticker.last : 0;
                
                // Use cached positions or find specific
                let pos = allPositions.find(p => p.symbol === symbol) || {};
                // Fallback if not in allPositions (rare)
                if(!pos.symbol && user.mode === 'real') {
                     try { 
                         const specific = await client.fetchPositions([symbol]); 
                         pos = specific[0] || {};
                     } catch(err) {}
                }
                
                if(currentPrice === 0) continue;
                
                const size = parseFloat(pos.contracts || 0);
                const entryPrice = parseFloat(pos.entryPrice || 0);
                const lev = parseFloat(pos.leverage || config.leverage || 10);
                
                // Explicit calc of Current PnL for checks
                let currentUnrealizedPnl = 0;
                if (size > 0 && entryPrice > 0) {
                    if (pos.side === 'long') currentUnrealizedPnl = (currentPrice - entryPrice) * size;
                    else currentUnrealizedPnl = (entryPrice - currentPrice) * size;
                }

                let currentRoi = 0;
                if(pos.roi !== undefined) {
                    currentRoi = parseFloat(pos.roi);
                } else {
                     const margin = (size * entryPrice) / lev;
                     if (margin > 0) {
                        currentRoi = (currentUnrealizedPnl / margin) * 100;
                     }
                }

                // ---------------------------------------------
                // 1. PROFIT PROTECTION LOGIC (RESTORED v46.42)
                // ---------------------------------------------
                if (size !== 0) {
                    let totalRealizedPnl = 0;
                    const history = user.mode === 'real' ? (user.real?.closedTrades || []) : (user.virtual?.closedTrades || []);
                    totalRealizedPnl = history.reduce((acc, t) => acc + (parseFloat(t.pnl) || 0), 0);

                    if (totalRealizedPnl > 0) {
                        const safetyBuffer = totalRealizedPnl / 5; // e.g. 100 / 5 = 20
                        
                        // LOGIC: If |Loss| is SMALLER than safety buffer, CLOSE.
                        // Requires Loss to be 'insignificant' relative to total gains.
                        // Formula: |Unrealized| < (Realized / 5)
                        if (currentUnrealizedPnl < 0 && Math.abs(currentUnrealizedPnl) < safetyBuffer && currentRoi < -10) {
                             console.log(`[${user.username}] ðŸ›¡ï¸ PROFIT PROTECTION: Closing ${symbol}. Abs(PnL): ${Math.abs(currentUnrealizedPnl).toFixed(2)} < Limit: ${safetyBuffer.toFixed(2)}, ROI: ${currentRoi.toFixed(2)}%`);
                             await closePosition(client, symbol, pos);
                             target.lastAction = 0; target.dcaCount = 0; dbUpdateNeeded = true; continue;
                        }
                    }
                }
                // ---------------------------------------------

                // 2. STOP LOSS LOGIC
                if (size !== 0 && currentRoi <= stopLossRoi) {
                     console.log(`[${user.username}] ðŸ›‘ STOP LOSS Triggered for ${symbol} at ${currentRoi.toFixed(2)}% (Limit: ${stopLossRoi}%)`);
                     await closePosition(client, symbol, pos);
                     target.lastAction = 0; target.dcaCount = 0; dbUpdateNeeded = true; continue;
                }

                // 3. MAIN DCA LOGIC (Aggressive Recovery)
                if (size !== 0 && currentRoi <= triggerRoi) {
                    const currentDcaCount = target.dcaCount || 0;
                    if (currentDcaCount < MAX_DCA_COUNT) {
                        if (!target.lastAction || (Date.now() - target.lastAction > 5000)) {
                            
                            // === DCA RESERVE CHECK (v46.42: Single Reserve) ===
                            // Standard Check: Free > Highest Min Cost.
                            if (freeUsdt < highestMinCost) {
                                if(!target.marginLogged) { console.log(`[${user.username}] âš ï¸ Low Margin. Skipping DCA for ${symbol}. Free: ${freeUsdt.toFixed(2)}, Needed High Reserve: ${highestMinCost.toFixed(2)}`); target.marginLogged = true; }
                                continue;
                            }
                            target.marginLogged = false;

                            const targetRoiDec = recoveryRoi / 100;
                            let targetAvgPrice = 0;
                            if (pos.side === 'long') targetAvgPrice = currentPrice / (1 + (targetRoiDec / lev));
                            else targetAvgPrice = currentPrice / (1 - (targetRoiDec / lev));
                            let qtyNeeded = (size * (targetAvgPrice - entryPrice)) / (currentPrice - targetAvgPrice);
                            if (qtyNeeded < 0) qtyNeeded = 0;
                            if (qtyNeeded > size * 2.5) qtyNeeded = size * 2.5; 
                            if (qtyNeeded < 1) qtyNeeded = 1;
                            const finalQty = Math.ceil(qtyNeeded);
                            
                            await client.setMarginMode('cross', symbol);
                            await client.createOrder(symbol, 'market', forcedSide, finalQty);
                            target.lastAction = Date.now();
                            target.dcaCount = currentDcaCount + 1;
                            dbUpdateNeeded = true;
                            continue; 
                        } else {
                            // Cooldown active
                        }
                    } else {
                        if(!target.maxDcaLogged) {
                            console.log(`[${user.username}] âš ï¸ DCA Skipped for ${symbol}: Max Count (${MAX_DCA_COUNT}) Reached. ROI: ${currentRoi.toFixed(2)}%`);
                            target.maxDcaLogged = true;
                        }
                    }
                } else {
                    target.maxDcaLogged = false;
                }

                // 4. GRADUAL DCA LOGIC (Slow accumulation: 1x Min Qty)
                if (size !== 0 && currentRoi <= gradualDcaRoi && currentRoi > triggerRoi) {
                     if (!target.lastAction || (Date.now() - target.lastAction > 5000)) {
                         
                         // Check Reserve (Same as Main DCA)
                         if (freeUsdt < highestMinCost) { continue; }

                         let minQty = 0.001;
                         try {
                            const market = client.market(symbol);
                            if (market && market.limits && market.limits.amount && market.limits.amount.min) {
                                minQty = market.limits.amount.min;
                            }
                         } catch(e) { minQty = 0.001; }

                         console.log(`[${user.username}] ðŸ¢ GRADUAL DCA for ${symbol}: Buying ${minQty}`);
                         
                         await client.setMarginMode('cross', symbol);
                         await client.createOrder(symbol, 'market', forcedSide, minQty);
                         
                         target.lastAction = Date.now();
                         dbUpdateNeeded = true;
                         continue;
                     }
                }

                // 5. TAKE PROFIT LOGIC
                if (size !== 0 && currentRoi >= profitRoi) {
                     await closePosition(client, symbol, pos);
                     target.lastAction = 0; target.dcaCount = 0; dbUpdateNeeded = true; continue;
                }

                // 6. NEW ENTRY LOGIC (If Closed)
                if(size === 0) {
                    if (!target.lastAction || (Date.now() - target.lastAction > 8000)) {
                        
                        let finalAmount = 0.001; 
                        try {
                            const market = client.market(symbol);
                            if (market && market.limits && market.limits.amount && market.limits.amount.min) {
                                finalAmount = market.limits.amount.min;
                            }
                        } catch(e) { finalAmount = 0.001; }
                        
                        finalAmount = finalAmount * multiplier;

                        // Calculate Cost for THIS specific coin
                        const myMinCost = (currentPrice * finalAmount) / lev;

                        // === NEW ENTRY CHECK (v46.42 AGGRESSIVE) ===
                        // Logic: "Only free margin largest value min tradable coin amount should be reserved"
                        let reserveNeeded = 0;
                        
                        // If I am NOT the expensive coin, AND the expensive coin is CLOSED, I must reserve for him.
                        if (symbol !== expensiveCoinSymbol && !isExpensiveOpen) {
                            reserveNeeded = highestMinCost;
                        }

                        if (freeUsdt < (myMinCost + reserveNeeded)) { continue; }

                        try { await client.setLeverage(lev, symbol); } catch(e){}
                        await client.setMarginMode('cross', symbol);
                        await client.createOrder(symbol, 'market', forcedSide, finalAmount);
                        target.lastAction = Date.now(); target.dcaCount = 0; dbUpdateNeeded = true;
                    }
                }
            } catch (e) { console.log(`âš ï¸ BOT ERROR [${symbol}]: ${e.message}`); }
        }
    }
    if(dbUpdateNeeded) saveDatabase();
    setTimeout(runBotLogic, 2000);
}

// ==========================================
// 6. HELPER FUNCTIONS
// ==========================================
async function getUserClient(user) {
    if (user.mode === 'real') {
        if (!user.realClient) {
            if (!user.realKeys.apiKey || !user.realKeys.secret) throw new Error("Real API Keys not set");
            user.realClient = new RealClientWrapper(user.realKeys.apiKey, user.realKeys.secret);
            user.realClient.parentUser = user; 
        }
        return user.realClient;
    } else {
        if (!user.client) user.client = new VirtualClient(user);
        return user.client;
    }
}

async function closePosition(client, symbol, pos = null) {
    if (!pos) {
        const positions = await client.fetchPositions([symbol]);
        pos = positions.find(p => p.symbol === symbol);
    }
    
    if (!pos || parseFloat(pos.contracts) === 0) {
        return; 
    }

    const size = parseFloat(pos.contracts);
    const entry = parseFloat(pos.entryPrice);
    const side = pos.side;
    const leverage = parseFloat(pos.leverage);

    if (client instanceof RealClientWrapper) {
        let closePrice = 0;
        let ticker = GLOBAL_TICKERS[symbol];

        if (ticker) {
            if(side === 'long') closePrice = ticker.bid || ticker.last;
            else closePrice = ticker.ask || ticker.last;
        } 
        else {
            const clean = symbol.split(':')[0].replace(/[^A-Z0-9]/g, '');
            ticker = Object.values(GLOBAL_TICKERS).find(t => t.symbol.replace(/[^A-Z0-9]/g, '').includes(clean));
            if (ticker) {
                if(side === 'long') closePrice = ticker.bid || ticker.last;
                else closePrice = ticker.ask || ticker.last;
            }
        }

        if (!closePrice) {
            try {
                const fresh = await client.fetchTicker(symbol);
                if (fresh) {
                    if(side === 'long') closePrice = fresh.bid || fresh.last;
                    else closePrice = fresh.ask || fresh.last;
                }
            } catch (e) {
                try {
                    const raw = client.getRawSymbol(symbol);
                    const freshRaw = await client.fetchTicker(raw + '_PERP');
                    if (freshRaw) {
                         if(side === 'long') closePrice = freshRaw.bid || freshRaw.last;
                         else closePrice = freshRaw.ask || freshRaw.last;
                    }
                } catch(err) {
                     console.log("[HitBTC] Price fetch failed for close:", err.message);
                }
            }
        }

        if (!closePrice || closePrice === 0) closePrice = entry; 

        let pnl = 0;
        if (side === 'long') pnl = (closePrice - entry) * size;
        else pnl = (entry - closePrice) * size;
        
        const margin = (size * entry) / leverage;
        const roi = margin > 0 ? (pnl / margin) * 100 : 0;

        if (client.parentUser) {
            if (!client.parentUser.real) client.parentUser.real = {};
            if (!client.parentUser.real.closedTrades) client.parentUser.real.closedTrades = [];
            
            client.parentUser.real.closedTrades.unshift({
                timestamp: Date.now(),
                symbol: symbol,
                side: side,
                qty: size,
                entry: entry,
                close: closePrice,
                pnl: pnl,
                roi: roi,
                status: 'CLOSED_LOCAL'
            });
            if (client.parentUser.real.closedTrades.length > 50) client.parentUser.real.closedTrades.pop();
        }

        return await client.closePosition(symbol);
    }

    const closeSide = pos.side === 'long' ? 'sell' : 'buy';
    return await client.createOrder(symbol, 'market', closeSide, pos.contracts);
}

function slugify(text) {
    if(!text) return 'article';
    return text.toString().toLowerCase().replace(/\s+/g, '-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-');
}

function getNewsData(cb) {
    const now = Date.now();
    if (newsCache.length > 0 && (now - lastNewsFetch) < 15 * 60 * 1000) {
        return cb(newsCache);
    }
    const newsUrl = `https://newsapi.org/v2/everything?q=cryptocurrency&sortBy=publishedAt&language=en&apiKey=${NEWS_API_KEY}`;
    https.get(newsUrl, { headers: { 'User-Agent': 'Node.js' } }, (res) => {
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => {
            try {
                const parsed = JSON.parse(data);
                if(parsed.articles) {
                    newsCache = parsed.articles;
                    lastNewsFetch = now;
                }
                cb(newsCache || []);
            } catch(e) { cb(newsCache || []); }
        });
    }).on('error', () => cb(newsCache || []));
}

function getTrackingScript() {
    return `<script src="/socket.io/socket.io.js"></script>
    <script>
        const trackingSocket = io();
        const pagePath = window.location.pathname;
        document.addEventListener('click', (e) => {
            let target = e.target;
            let text = target.innerText || target.value || target.id || 'Unknown';
            if(text.length > 50) text = text.substring(0,50) + '...';
            trackingSocket.emit('user_click', { page: pagePath, text: text, tag: target.tagName });
        });
        setInterval(() => {
            const scroll = Math.round((window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100) || 0;
            trackingSocket.emit('tracking_data', { page: pagePath, scrollPercent: scroll });
        }, 2000);
    </script>`;
}

// ------------------------------------------------
// UI RENDERER (CSS HEIGHT FIXES APPLIED)
// ------------------------------------------------
function renderLayout(title, content, user, meta = {}) {
    const isReal = user && user.mode === 'real';
    const headerColor = isReal ? '#c62828' : '#6200ea'; // Deep Red or Deep Purple
    const modeName = isReal ? 'REAL HITBTC' : 'VIRTUAL';
    const userCurr = user ? (user.currency || 'USD') : 'USD';
    
    let newsTicker = '';
    if(newsCache && newsCache.length > 0) {
        const safeNews = newsCache.filter(n => n.title).slice(0, 5);
        if(safeNews.length > 0) {
            newsTicker = `<div style="background:#000; color:#00e676; white-space:nowrap; overflow:hidden; font-size:0.8rem; padding:6px 0; border-bottom:1px solid #222;">
                <div style="display:inline-block; animation:ticker 30s linear infinite; padding-left:100%;">
                    <span style="font-weight:bold; color:white; margin-right:10px;">âš¡ NEWS:</span>
                    ${safeNews.map(n => `<a href="/news/view/${slugify(n.title)}" style="color:#00e676; text-decoration:none; margin-right:30px; font-weight:bold;">${n.title}</a>`).join('')}
                </div>
            </div>
            <style>@keyframes ticker { 0% { transform: translate3d(0, 0, 0); } 100% { transform: translate3d(-100%, 0, 0); } }</style>`;
        }
    }

    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <title>${title} | HitBTC Bot</title>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
        <style>
            :root { 
                --primary: ${headerColor}; 
                --bg: #f0f2f5; 
                --surface: #ffffff; 
                --text: #202124; 
                --text-secondary: #5f6368; 
                --green: #2e7d32; 
                --red: #c62828; 
                --border: #dadce0;
                --shadow-1: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
                --shadow-2: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
                --radius: 8px;
            }
            body { background: var(--bg); color: var(--text); font-family: 'Roboto', sans-serif; margin: 0; padding: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
            
            /* Header */
            header { background: var(--primary); height: 60px; display: flex; align-items: center; justify-content: space-between; padding: 0 24px; box-shadow: var(--shadow-2); flex-shrink: 0; z-index: 1000; }
            .logo { font-weight: 700; font-size: 1.25rem; color: white; text-decoration: none; display: flex; align-items: center; gap: 10px; }
            .header-right a { color: rgba(255,255,255,0.9); text-decoration: none; margin-left: 20px; font-size: 0.9rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; }

            /* Material Cards with Layout Fixes */
            .card { 
                background: var(--surface); 
                border-radius: var(--radius); 
                box-shadow: var(--shadow-1); 
                padding: 16px; 
                transition: 0.3s cubic-bezier(.25,.8,.25,1); 
                border:none; 
                position:relative; 
                
                /* FLEX LAYOUT FOR INTERNAL CONTENT */
                display: flex;
                flex-direction: column;
                box-sizing: border-box;
            }
            .card:hover { box-shadow: var(--shadow-2); }
            
            /* Layout Grid */
            .container { flex: 1; display: grid; grid-template-columns: 320px 1fr 360px; grid-template-rows: 60px 1fr 340px; gap: 16px; padding: 16px; overflow: hidden; height: 100%; box-sizing: border-box; }
            
            /* Grid Areas with Explicit Heights */
            .ticker-bar { grid-column: 1 / 4; grid-row: 1; display: flex; flex-direction: row; align-items: center; justify-content: space-between; padding: 0 24px; }
            .order-book { grid-column: 1; grid-row: 2 / 4; height: 100%; overflow: hidden; padding: 0; }
            .chart-area { grid-column: 2; grid-row: 2; height: 100%; padding: 0; overflow: hidden; }
            .orders-panel { grid-column: 2; grid-row: 3; height: 100%; overflow: hidden; padding: 0; }
            
            /* Sidebar: Let it Scroll naturally */
            .sidebar { 
                grid-column: 3; 
                grid-row: 2 / 4; 
                overflow-y: auto; 
                display: flex; 
                flex-direction: column; 
                gap: 16px; 
                padding-bottom: 20px;
                height: 100%;
            }
            /* Sidebar cards shouldn't fill 100% height, they stack */
            .sidebar .card {
                height: auto;
                flex-shrink: 0;
            }

            /* Material Typography */
            h3 { font-size: 1rem; font-weight: 500; color: var(--text-secondary); margin: 0 0 16px 0; text-transform: uppercase; letter-spacing: 0.5px; }
            .data-val-lg { font-size: 1.5rem; font-weight: 400; color: var(--text); }
            .data-label { font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 500; }
            
            /* Material Buttons */
            .btn { width: 100%; padding: 10px 16px; border: none; border-radius: 4px; font-weight: 500; cursor: pointer; color: #fff; font-size: 0.875rem; text-transform: uppercase; letter-spacing: 0.75px; box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 0 1px 5px 0 rgba(0,0,0,0.12); transition: 0.2s; position: relative; overflow: hidden; }
            .btn:active { box-shadow: none; transform: translateY(1px); }
            .btn-primary { background: var(--primary); }
            .btn-buy { background: var(--green); }
            .btn-sell { background: var(--red); }
            .btn-text { background: transparent; color: var(--primary); box-shadow: none; width: auto; padding: 6px 12px; }
            .btn-text:hover { background: rgba(0,0,0,0.04); }

            /* Material Inputs (Filled) */
            .input-group { position: relative; background: #f5f5f5; border-radius: 4px 4px 0 0; border-bottom: 2px solid transparent; margin-bottom: 12px; transition: background 0.2s; }
            .input-group:hover { background: #ececec; }
            .input-group:focus-within { background: #e8e8e8; border-bottom-color: var(--primary); }
            .input-group label { position: absolute; top: 8px; left: 12px; font-size: 0.7rem; color: var(--text-secondary); font-weight: 500; }
            .input-group input, .input-group select { width: 100%; border: none; background: transparent; padding: 24px 12px 6px; font-size: 1rem; color: var(--text); outline: none; box-sizing: border-box; font-family: 'Roboto', sans-serif; }
            
            /* Material Tabs (Segmented) */
            .tabs { display: flex; background: #e0e0e0; padding: 4px; border-radius: 4px; margin-bottom: 16px; }
            .tab { flex: 1; text-align: center; padding: 8px; font-size: 0.85rem; font-weight: 500; text-transform: uppercase; color: var(--text-secondary); cursor: pointer; border-radius: 4px; transition: 0.2s; }
            .tab.active { background: white; color: var(--primary); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
            
            /* Lists & Tables */
            .stat-row { display: flex; justify-content: space-between; align-items: baseline; padding: 10px 0; border-bottom: 1px solid #f0f0f0; }
            .stat-row:last-child { border-bottom: none; }
            .text-green { color: var(--green); } 
            .text-red { color: var(--red); }
            
            /* Order Book */
            .ob-header { display: flex; padding: 10px 16px; background: #fafafa; font-size: 0.75rem; color: var(--text-secondary); font-weight: 500; text-transform: uppercase; border-bottom: 1px solid var(--border); }
            .ob-row { display: flex; justify-content: space-between; padding: 4px 16px; font-family: 'Roboto Mono', monospace; font-size: 0.8rem; cursor: pointer; transition: background 0.1s; }
            .ob-row:hover { background: #f5f5f5; }
            .spread-bar { padding: 8px; text-align: center; font-weight: bold; font-family: 'Roboto Mono', monospace; background: #fafafa; border-top: 1px solid var(--border); border-bottom: 1px solid var(--border); }
            
            /* Order Tabs */
            .order-tabs { display: flex; border-bottom: 1px solid var(--border); background: white; }
            .order-tab-item { padding: 14px 24px; font-size: 0.85rem; font-weight: 500; text-transform: uppercase; color: var(--text-secondary); cursor: pointer; border-bottom: 2px solid transparent; transition: 0.2s; }
            .order-tab-item.active { color: var(--primary); border-bottom-color: var(--primary); }
            
            /* Chips */
            .chip { display: inline-flex; align-items: center; padding: 4px 8px; border-radius: 16px; background: #e0e0e0; font-size: 0.75rem; margin-right: 4px; margin-bottom: 4px; font-weight: 500; }
            .chip-action { cursor: pointer; background: #e8f0fe; color: var(--primary); }

            table { width: 100%; border-collapse: collapse; }
            th { text-align: left; font-size: 0.75rem; color: var(--text-secondary); font-weight: 500; text-transform: uppercase; padding: 12px 16px; border-bottom: 1px solid var(--border); background: #fafafa; position: sticky; top: 0; }
            td { padding: 10px 16px; font-size: 0.85rem; border-bottom: 1px solid #f0f0f0; }

            .virtual-banner { background: #323232; color: #fff; text-align: center; font-size: 0.75rem; padding: 6px; font-weight: 500; letter-spacing: 0.5px; z-index: 2000; position:relative; }
            
            /* Responsive */
            @media (max-width: 1000px) {
                body { overflow-y: auto; height: auto; }
                .container { display: flex; flex-direction: column; gap: 10px; padding: 10px; height: auto; }
                .sidebar { padding-bottom: 40px; overflow: visible; height: auto; }
                .chart-area { min-height: 400px; }
                .orders-panel { min-height: 400px; }
                .order-book { display: none; }
                .ticker-bar { flex-wrap: wrap; gap: 10px; padding: 16px; height: auto; }
            }
        </style>
        <script>
            function addCoin(symbol) { fetch('/bot/add', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ symbol }) }).then(r => r.json()).then(d => { if(d.success) location.reload(); }); }
            function addAllCoins() { if(confirm('Add ALL supported coins?')) fetch('/bot/add-all', { method: 'POST' }).then(() => location.reload()); }
            function removeCoin(symbol) { fetch('/bot/remove', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ symbol }) }).then(() => { const el = document.getElementById('coin-' + symbol.replace(/[^a-zA-Z]/g, '')); if(el) el.remove(); }); }
            function clearCoins() { fetch('/bot/clear', { method: 'POST' }).then(() => location.reload()); }
            function setBalance() { 
                const amount = prompt("Enter new Virtual Wallet Balance:"); 
                if(amount && !isNaN(amount)) { fetch('/api/set-balance', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ amount }) }).then(() => location.reload()); } 
            }
            function switchMode() { 
                if(confirm("Switch Trading Mode (Virtual <-> Real HitBTC)?")) {
                    fetch('/api/switch-mode', { method: 'POST' })
                    .then(r=>r.json())
                    .then(d => { if(d.success) location.reload(); });
                }
            }
            function updateBotSettings(e) { e.preventDefault(); const formData = new FormData(e.target); const data = Object.fromEntries(formData.entries()); fetch('/bot/update', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(data) }).then(r => r.json()).then(d => { if(d.success) location.reload(); }); }
            function resetPnl() { if(confirm('Reset Realized PnL and History?')) fetch('/api/reset-pnl', { method: 'POST' }).then(() => location.reload()); }
            function resetMaxMargin() { if(confirm('Reset Max Margin Stat?')) fetch('/api/reset-max-margin', { method: 'POST' }).then(() => location.reload()); }
            function triggerDCA(symbol) {
                if(confirm('Trigger Immediate DCA Buy for ' + symbol + '?')) {
                    fetch('/bot/manual-dca', { 
                        method: 'POST', 
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ symbol })
                    })
                    .then(r => r.json())
                    .then(d => { if(d.success) alert('DCA Executed!'); else alert('Failed: ' + d.message); });
                }
            }
        </script>
    </head>
    <body>
        <div class="virtual-banner">CURRENT MODE: ${modeName} - ${isReal ? 'âš ï¸ REAL FUNDS AT RISK' : 'SIMULATION ONLY'}</div>
        ${newsTicker}
        <header>
            <a href="/" class="logo">âš¡ HitBTC Bot</a>
            <div class="header-right">
                <a href="/">Dashboard</a>
                <a href="/news">News</a>
                <a onclick="switchMode()" style="cursor:pointer; background:rgba(255,255,255,0.2); padding:4px 10px; border-radius:4px;">${isReal ? 'Go Virtual' : 'Go Real'}</a>
                ${user ? `<a href="/profile">Profile</a><a href="/logout">Logout</a>` : `<a href="/login">Login</a>`}
            </div>
        </header>
        ${content}
        ${getTrackingScript()}
    </body>
    </html>`;
}

// ==========================================
// 7. ROUTING
// ==========================================
app.get('/', async (req, res) => {
    if(!req.session.userId) return res.redirect('/login');
    const user = users.find(u => u.id === req.session.userId);
    if (!user) { req.session.destroy(); return res.redirect('/login'); }
    
    const userCurr = user.currency || 'USD';
    const rate = CURRENCIES[userCurr].rate;
    const sym = CURRENCIES[userCurr].symbol;
    const isReal = user.mode === 'real';

    let selectedPair = SUPPORTED_PAIRS[0];
    if (req.query.symbol) {
        const q = req.query.symbol.trim();
        const clean = q.toUpperCase().replace(/[^A-Z0-9]/g, '');
        const found = SUPPORTED_PAIRS.find(p => p.split(':')[0].replace('/', '') === clean);
        if (found) selectedPair = found;
    }
    
    const rawSymbol = selectedPair.split(':')[0].replace('/', '');
    const tvSymbol = `HITBTC:${rawSymbol}`; 
    const cleanPair = rawSymbol;
    const displayPair = selectedPair.replace(':USDT', ''); 
    const quote = 'USDT';

    let tradableListHTML = '<div style="color:#999;font-size:0.8rem;">Loading...</div>';
    let positions = [];

    try {
        const client = await getUserClient(user);
        const [balanceData, tickers, allPositions] = await Promise.all([
            client.fetchBalance(),
            client.fetchTickers(SUPPORTED_PAIRS),
            client.fetchPositions() // Fetch all positions for UI logic
        ]);
        positions = allPositions;
        const usdtBal = balanceData.USDT ? parseFloat(balanceData.USDT.free) : 0;
        const dispBal = usdtBal * rate;
        const LEV = user.bot.leverage || 10;
        const coinAnalysis = SUPPORTED_PAIRS.map(s => {
            const ticker = tickers[s] || {};
            const market = client.market(s);
            const minAmount = (market.limits && market.limits.amount && market.limits.amount.min) ? market.limits.amount.min : 0.001;
            const safePrice = ticker.last || 0;
            const cost = (safePrice * minAmount) / LEV; 
            return { symbol: s, display: s.replace('/USDT:USDT',''), cost: cost, price: safePrice };
        });
        const affordable = coinAnalysis.filter(c => c.cost <= usdtBal && c.price > 0);
        if(affordable.length > 0) {
            tradableListHTML = `
                <div style="margin-bottom:12px; border-bottom:1px dashed #eee; padding-bottom:8px;">
                    <div style="font-size:0.75rem; color:var(--text-secondary); margin-bottom:8px; font-weight:500;">Add to Bot (Bud: ${sym}${dispBal.toFixed(2)}):</div>
                    <div style="display:flex; flex-wrap:wrap;">
                    ${affordable.map(c => `<span class="chip chip-action" onclick="addCoin('${c.symbol}')">+ ${c.display}</span>`).join(' ')}
                    </div>
                </div>`;
        }
    } catch(e) { tradableListHTML = `<div style="color:var(--red);font-size:0.8rem;">Error: ${e.message}</div>`; }

    // --- RESTRUCTURED ACTIVE COINS LIST WITH ROI & RECOVERY QTY ---
    const activeListHTML = user.bot.coins.map((c) => {
        // Calculate recovery qty logic for display
        const pos = positions.find(p => p.symbol === c.symbol) || {};
        const size = parseFloat(pos.contracts || 0);
        let recQtyDisplay = '-';
        let currentRoiDisplay = '0.00%';
        let roiColor = 'var(--text-secondary)';

        if(size > 0) {
            const ticker = GLOBAL_TICKERS[c.symbol] || {};
            const currentPrice = ticker.last || parseFloat(pos.entryPrice);
            const entryPrice = parseFloat(pos.entryPrice);
            const lev = parseFloat(pos.leverage || user.bot.leverage || 10);
            
            // Calculate ROI
            let upnl = 0;
            if(pos.side === 'long') upnl = (currentPrice - entryPrice) * size;
            else upnl = (entryPrice - currentPrice) * size;
            const margin = (size * entryPrice) / lev;
            const roi = margin > 0 ? (upnl / margin) * 100 : 0;
            
            currentRoiDisplay = roi.toFixed(2) + '%';
            roiColor = roi >= 0 ? 'var(--green)' : 'var(--red)';

            // Calculate Recovery Qty (based on target ROI)
            const targetRoiDec = (user.bot.recoveryRoi || -5) / 100;
            let targetAvgPrice = 0;
            if (pos.side === 'long') targetAvgPrice = currentPrice / (1 + (targetRoiDec / lev));
            else targetAvgPrice = currentPrice / (1 - (targetRoiDec / lev));
            
            let qtyNeeded = (size * (targetAvgPrice - entryPrice)) / (currentPrice - targetAvgPrice);
            if (qtyNeeded < 0) qtyNeeded = 0;
            recQtyDisplay = Math.ceil(qtyNeeded).toString();
        }

        return `
        <div class="stat-row" id="coin-${c.symbol.replace(/[^a-zA-Z]/g, '')}">
            <div style="flex:1;">
                <div style="display:flex; align-items:center; margin-bottom:2px;">
                    <span style="font-weight:500; font-size:0.9rem;">${c.symbol.replace('/USDT:USDT','')}</span>
                    <span class="chip" style="margin-left:8px; height:18px; font-size:0.65rem; background:${c.side==='buy'?'#e6f4ea':'#fce8e6'}; color:${c.side==='buy'?'var(--green)':'var(--red)'}">${c.side.toUpperCase()}</span>
                </div>
                <div style="font-size:0.75rem; color:var(--text-secondary);">
                    ROI: <span style="color:${roiColor}; font-weight:bold;">${currentRoiDisplay}</span> | Est. Rec. Qty: <strong>${recQtyDisplay}</strong>
                </div>
            </div>
            <div style="display:flex; gap:8px;">
                <button onclick="triggerDCA('${c.symbol}')" class="btn" style="width:auto; padding:4px 8px; font-size:0.7rem; background:#ff9800; color:white;" title="DCA NOW">âš¡</button>
                <button onclick="removeCoin('${c.symbol}')" style="background:none; border:none; color:#ccc; cursor:pointer; font-weight:bold; font-size:1.1rem;">&times;</button>
            </div>
        </div>`;
    }).join('');

    let realKeysForm = '';
    if(user.mode === 'real') {
        realKeysForm = `
        <div class="card" style="border-left: 4px solid var(--red);">
            <h3>API Configuration</h3>
            <form action="/api/save-keys" method="POST">
                <div class="input-group"><label>API Key</label><input type="text" name="apiKey" value="${user.realKeys.apiKey || ''}"></div>
                <div class="input-group"><label>API Secret</label><input type="password" name="secret" value="${user.realKeys.secret || ''}"></div>
                <button class="btn btn-sell">Save Keys</button>
            </form>
        </div>`;
    }

    // --- NEW SIDEBAR HTML STRUCTURE (MATERIAL DESIGN) ---
    res.send(renderLayout('Dashboard', `
        <div class="container">
            <!-- Ticker Bar -->
            <div class="card ticker-bar">
                <form action="/" method="GET" style="margin:0;">
                    <div class="input-group" style="margin:0; width:140px; background:transparent;">
                        <label>Select Pair</label>
                        <select name="symbol" onchange="this.form.submit()">
                            ${SUPPORTED_PAIRS.map(p => {
                                const c = p.split(':')[0].replace('/', '');
                                return `<option value="${c}" ${p === selectedPair ? 'selected' : ''}>${p.replace(':USDT','')}</option>`;
                            }).join('')}
                        </select>
                    </div>
                </form>
                <div>
                    <span class="data-label">Last Price</span>
                    <span id="price" class="data-val-lg" style="margin-left:10px; color:var(--green)">---</span>
                </div>
            </div>

            <!-- Order Book -->
            <div class="card order-book">
                <div class="ob-header"><span>Price (${quote})</span><span>Size</span></div>
                <div id="asks" style="flex:1; overflow-y:auto; overflow-x:hidden; display:flex; flex-direction:column-reverse;"></div>
                <div id="midPrice" class="spread-bar">---</div>
                <div id="bids" style="flex:1; overflow-y:auto; overflow-x:hidden;"></div>
            </div>

            <!-- Chart -->
            <div class="card chart-area">
                <div class="tradingview-widget-container" style="height:100%;width:100%">
                  <div id="tradingview_b1e3e" style="height:100%;width:100%"></div>
                  <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
                  <script type="text/javascript">
                  new TradingView.widget({
                    "autosize": true, "symbol": "${tvSymbol}", "interval": "15", "timezone": "Etc/UTC", "theme": "light", "style": "1", "locale": "en", "enable_publishing": false, "allow_symbol_change": false, "container_id": "tradingview_b1e3e", "hide_side_toolbar": false
                  });
                  </script>
                </div>
            </div>

            <!-- Orders Panel -->
            <div class="card orders-panel">
                <div class="order-tabs">
                    <div id="tab-active" class="order-tab-item active" onclick="switchOrderTab('active')">Active</div>
                    <div id="tab-filled" class="order-tab-item" onclick="switchOrderTab('filled')">History</div>
                    <div id="tab-positions" class="order-tab-item" onclick="switchOrderTab('positions')">Positions</div>
                    <div id="tab-closed" class="order-tab-item" onclick="switchOrderTab('closed')">Closed</div>
                    <div style="margin-left:auto; padding:12px; cursor:pointer;" onclick="refreshCurrentTab()">â†»</div>
                </div>
                <div style="flex:1; overflow-y:auto;" id="view-active"><table id="ordersTable"><thead><tr><th>Side</th><th>Price</th><th>Size</th><th>Action</th></tr></thead><tbody id="ordersBody"></tbody></table></div>
                <div style="flex:1; overflow-y:auto; display:none;" id="view-filled"><table id="filledTable"><thead><tr><th>Time</th><th>Side</th><th>Price</th><th>Size</th><th>Cost</th></tr></thead><tbody id="filledBody"></tbody></table></div>
                <div style="flex:1; overflow-y:auto; display:none;" id="view-positions"><table id="positionsTable"><thead><tr><th>Symbol</th><th>Side</th><th>Lev</th><th>Size</th><th>Liq.Price</th><th>PnL (${sym})</th><th>ROI</th><th>Action</th></tr></thead><tbody id="positionsBody"></tbody></table></div>
                <div style="flex:1; overflow-y:auto; display:none;" id="view-closed"><table id="closedTable"><thead><tr><th>Time</th><th>Symbol</th><th>Side</th><th>Price</th><th>PnL</th><th>ROI</th></tr></thead><tbody id="closedBody"></tbody></table></div>
            </div>

            <!-- OVERHAULED SIDEBAR -->
            <div class="sidebar">
                ${realKeysForm}
                
                <!-- Account Card -->
                <div class="card">
                    <h3>Account Overview</h3>
                    <div class="stat-row">
                        <span class="data-label">Equity ${user.mode === 'virtual' ? '<span onclick="setBalance()" style="cursor:pointer;font-size:14px;color:var(--primary);">âœŽ</span>' : ''}</span>
                        <span id="balance" style="font-weight:700; color:var(--text);">...</span>
                    </div>
                    <div class="stat-row">
                        <span class="data-label">Free Margin</span>
                        <span id="marginFree">0.00</span>
                    </div>
                    <div class="stat-row">
                        <span class="data-label">Margin Used</span>
                        <span id="marginUsed">0.00</span>
                    </div>
                    <div class="stat-row">
                        <span class="data-label">Unrealized PnL</span>
                        <span id="upnl">0.00</span>
                    </div>
                    <div class="stat-row">
                        <span class="data-label">Realized PnL <sup onclick="resetPnl()" style="cursor:pointer;color:var(--red)">[x]</sup></span>
                        <span id="closedPnl">0.00</span>
                    </div>
                    <div class="stat-row">
                        <span class="data-label">Max Margin <sup onclick="resetMaxMargin()" style="cursor:pointer;color:var(--red)">[x]</sup></span>
                        <span id="maxMargin">0.00</span>
                    </div>
                    
                    <div style="background:#f5f5f5; border-radius:4px; padding:8px 12px; margin-top:12px;">
                        <span class="data-label" style="display:block; margin-bottom:4px;">Est. Yield (${sym})</span>
                        <div style="display:flex; justify-content:space-between;">
                            <small>Hourly: <span id="estHour" class="text-green">0.00</span></small>
                            <small>Yearly: <span id="estYear" class="text-green">0.00</span></small>
                        </div>
                    </div>

                    <div style="display:flex; gap:8px; margin-top:16px;">
                        <button class="btn btn-primary" onclick="closeCurrentPosition()" style="background:#455a64;">Close Pos</button>
                        <button class="btn btn-sell" onclick="closeAllPositions()">Close All</button>
                    </div>
                </div>

                <!-- Bot Configuration Card -->
                <div class="card">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
                        <h3 style="margin:0;">Bot Engine</h3>
                        <span class="chip" style="${user.bot.active ? 'background:#e6f4ea; color:#1e8e3e;' : 'background:#fce8e6; color:#c62828;'} font-weight:bold;">${user.bot.active ? 'RUNNING' : 'STOPPED'}</span>
                    </div>
                    
                    <div style="max-height:200px; overflow-y:auto; border:1px solid #f0f0f0; border-radius:4px; padding:0 8px; margin-bottom:12px;">
                        ${activeListHTML || '<div style="padding:10px; text-align:center; font-size:0.8rem; color:#999;">No active pairs</div>'}
                    </div>
                    ${tradableListHTML}

                    <div style="text-align:right; margin-bottom:12px;">
                        <span class="btn-text" onclick="addAllCoins()" style="cursor:pointer; font-size:0.75rem;">+ ADD ALL</span>
                        <span class="btn-text" onclick="clearCoins()" style="cursor:pointer; font-size:0.75rem; color:var(--red);">CLEAR</span>
                    </div>
                    
                    <form onsubmit="updateBotSettings(event)">
                        <input type="hidden" name="symbol" value="${cleanPair}">
                        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
                            <div class="input-group"><label>Leverage</label><input type="number" name="leverage" value="${user.bot.leverage}"></div>
                            <div class="input-group"><label>Multiplier</label><input type="number" name="tradeMultiplier" value="${user.bot.tradeMultiplier || 1}" step="0.5"></div>
                            <div class="input-group"><label>DCA Trigger %</label><input type="number" name="triggerRoi" value="${user.bot.triggerRoi || -15}"></div>
                            <div class="input-group"><label>DCA Target %</label><input type="number" name="recoveryRoi" value="${user.bot.recoveryRoi || -5}"></div>
                            <div class="input-group" style="grid-column:1/-1;"><label>Gradual DCA %</label><input type="number" name="gradualDcaRoi" value="${user.bot.gradualDcaRoi || -5}" placeholder="-5"></div>
                            <div class="input-group"><label>Take Profit %</label><input type="number" name="profitRoi" value="${user.bot.profitRoi || 6}"></div>
                            <div class="input-group"><label>Stop Loss %</label><input type="number" name="stopLossRoi" value="${user.bot.stopLossRoi || -50}"></div>
                        </div>
                        <button class="btn" style="background:${user.bot.active ? 'var(--red)' : 'var(--green)'}; margin-top:10px;">${user.bot.active ? 'STOP ENGINE' : 'START ENGINE'}</button>
                    </form>
                </div>

                <!-- Manual Trade Card -->
                <div class="card">
                    <h3>Manual Trade</h3>
                    <div class="tabs">
                        <div class="tab active" id="tabLimit" onclick="switchTab('limit')">Limit</div>
                        <div class="tab" id="tabMarket" onclick="switchTab('market')">Market</div>
                    </div>
                    
                    <div id="priceGroup" class="input-group">
                        <label>Price (${quote})</label>
                        <input type="number" id="tradePrice" step="0.1" placeholder="0.00">
                    </div>
                    
                    <div style="display:grid; grid-template-columns: 2fr 1fr; gap:12px;">
                        <div class="input-group">
                            <label>Amount</label>
                            <input type="number" id="tradeAmount" step="1" placeholder="Qty">
                        </div>
                        <div class="input-group">
                            <label>Lev (x)</label>
                            <input type="number" id="manualLev" value="10" min="1" max="100">
                        </div>
                    </div>

                    <div style="display:flex; gap:10px; margin-top:8px;">
                        <button class="btn btn-buy" onclick="placeOrder('buy')">Long</button>
                        <button class="btn btn-sell" onclick="placeOrder('sell')">Short</button>
                    </div>
                </div>
            </div>
        </div>
        <script src="/socket.io/socket.io.js"></script>
        <script>
            const socket = io();
            const symbol = "${selectedPair}";
            let orderType = 'limit';
            let currentView = 'active';

            socket.on('market_' + symbol, data => {
                document.getElementById('price').innerText = data.price.toFixed(2);
                document.getElementById('midPrice').innerText = data.price.toFixed(2);
                const row = (p, a, c) => \`<div class="ob-row" onclick="fillPrice(\${p})"><span class="\${c}" style="font-weight:700;">\${p.toFixed(2)}</span><span>\${a}</span></div>\`;
                document.getElementById('asks').innerHTML = data.asks.map(x => row(x[0], x[1], 'text-red')).join('');
                document.getElementById('bids').innerHTML = data.bids.map(x => row(x[0], x[1], 'text-green')).join('');
            });
            function switchTab(type) {
                orderType = type;
                document.getElementById('tabLimit').className = (type === 'limit' ? 'tab active' : 'tab');
                document.getElementById('tabMarket').className = (type === 'market' ? 'tab active' : 'tab');
                document.getElementById('priceGroup').style.display = (type === 'limit' ? 'block' : 'none');
            }
            function switchOrderTab(view) {
                currentView = view;
                document.querySelectorAll('.order-tab-item').forEach(e => e.classList.remove('active'));
                document.getElementById('tab-' + view).classList.add('active');
                ['active','filled','positions','closed'].forEach(v => document.getElementById('view-'+v).style.display = 'none');
                document.getElementById('view-' + view).style.display = 'block';
                refreshCurrentTab();
            }
            function refreshCurrentTab() {
                if(currentView === 'active') fetchOrders(); 
                else if(currentView === 'filled') fetchHistory();
                else if(currentView === 'positions') fetchPositions();
                else if(currentView === 'closed') fetchClosed();
            }
            function fillPrice(p) { if(orderType === 'limit') document.getElementById('tradePrice').value = p; }
            function placeOrder(side) {
                const amount = document.getElementById('tradeAmount').value;
                const price = document.getElementById('tradePrice').value;
                const leverage = document.getElementById('manualLev').value;
                fetch('/api/trade', {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ symbol, side, type: orderType, amount, price, leverage })
                }).then(r => r.json()).then(d => { if(d.success) refreshCurrentTab(); else alert('Error: ' + d.error); });
            }
            function closeCurrentPosition() { if(confirm('Close '+symbol+'?')) fetch('/api/close', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ symbol }) }).then(() => refreshCurrentTab()); }
            function closeAllPositions() { if(confirm('CLOSE ALL POSITIONS?')) fetch('/api/close-all', { method: 'POST' }).then(() => refreshCurrentTab()); }
            function fetchOrders() { fetch('/api/orders?symbol='+symbol).then(r=>r.json()).then(d => document.getElementById('ordersBody').innerHTML = d.map(o => \`<tr><td class="\${o.side=='buy'?'text-green':'text-red'}">\${o.side.toUpperCase()}</td><td>\${o.price}</td><td>\${o.amount}</td><td><button style="border:none;background:none;cursor:pointer;font-weight:bold;" onclick="cancelOrder('\${o.id}')">&times;</button></td></tr>\`).join('')); }
            function fetchHistory() { fetch('/api/history?symbol='+symbol).then(r=>r.json()).then(d => document.getElementById('filledBody').innerHTML = d.map(o => \`<tr><td>\${new Date(o.timestamp).toLocaleTimeString()}</td><td class="\${o.side=='buy'?'text-green':'text-red'}">\${o.side.toUpperCase()}</td><td>\${o.price}</td><td>\${o.amount}</td><td>\${o.cost.toFixed(2)}</td></tr>\`).join('')); }
            function fetchPositions() { fetch('/api/raw-positions').then(r=>r.json()).then(d => document.getElementById('positionsBody').innerHTML = d.map(o => \`<tr><td>\${o.symbol.replace(':USDT','')}</td><td class="\${o.side=='long'?'text-green':'text-red'}">\${o.side.toUpperCase()}</td><td>\${o.leverage}x</td><td>\${o.size}</td><td>\${parseFloat(o.liquidationPrice).toFixed(2)}</td><td class="\${parseFloat(o.pnl)>=0?'text-green':'text-red'}">\${o.pnl}</td><td>\${parseFloat(o.roi).toFixed(2)}%</td><td><button class="btn btn-sell" style="padding:4px 8px; font-size:10px; width:auto;" onclick="closeSpecific('\${o.symbol}')">CLOSE</button></td></tr>\`).join('')); }
            function fetchClosed() { fetch('/api/closed-positions?symbol='+symbol).then(r=>r.json()).then(d => document.getElementById('closedBody').innerHTML = d.map(o => \`<tr><td>\${new Date(o.timestamp).toLocaleTimeString()}</td><td>\${o.symbol}</td><td class="\${o.side=='long'?'text-green':'text-red'}">\${o.side.toUpperCase()}</td><td>\${o.close}</td><td class="\${parseFloat(o.pnl)>=0?'text-green':'text-red'}">\${o.pnl}</td><td>\${o.roi}%</td></tr>\`).join('')); }
            function cancelOrder(id) { fetch('/api/cancel', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ id, symbol }) }).then(() => fetchOrders()); }
            function closeSpecific(s) { fetch('/api/close', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ symbol: s }) }).then(() => refreshCurrentTab()); }
            setInterval(() => {
                fetch('/api/position?symbol=' + symbol).then(r => r.json()).then(d => {
                    document.getElementById('upnl').innerText = d.upnl; document.getElementById('upnl').className = 'data-val-lg ' + (parseFloat(d.upnl)>=0?'text-green':'text-red');
                    document.getElementById('closedPnl').innerText = d.closedPnl;
                    
                    document.getElementById('maxMargin').innerText = d.maxMargin;
                    document.getElementById('balance').innerText = d.balance;
                    document.getElementById('marginFree').innerText = d.marginFree;
                    document.getElementById('marginUsed').innerText = d.marginUsed;
                    
                    document.getElementById('estHour').innerText = d.estHour || '0.00';
                    document.getElementById('estYear').innerText = d.estYear || '0.00';
                });
            }, 2000);
            refreshCurrentTab();
        </script>
    `, user));
});

// Admin Routes
app.get('/admin', (req, res) => {
    if(req.session.isAdmin) {
        // Prepare Data for Charts & Cards
        const activeUsers = users.length;
        // CHANGED: Use totalViews if available, else fallback to array length
        const totalViews = analytics.totalViews || analytics.pageViews.length;
        const botStarts = analytics.botStarts;
        
        let systemPnl = 0;
        users.forEach(u => {
            const h = u.mode === 'real' ? (u.real?.closedTrades || []) : (u.virtual?.closedTrades || []);
            systemPnl += h.reduce((acc, t) => acc + (parseFloat(t.pnl)||0), 0);
        });

        // Chart Data: Views per Hour (Approx)
        const hourCounts = {};
        analytics.pageViews.forEach(v => {
            // Updated to show HH:00 based on server time clearly
            const date = new Date(v.time);
            const h = date.getHours().toString().padStart(2, '0') + ":00"; 
            hourCounts[h] = (hourCounts[h] || 0) + 1;
        });
        
        const chartLabels = Object.keys(hourCounts).sort();
        const chartData = chartLabels.map(label => hourCounts[label]);

        // Top Pages
        const pages = {};
        analytics.pageViews.forEach(v => { pages[v.path] = (pages[v.path] || 0) + 1; });
        const topPages = Object.entries(pages).sort((a,b)=>b[1]-a[1]).slice(0,5);

        return res.send(renderLayout('Admin Dashboard', `
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <script>
            function deleteUser(userId) {
                if(confirm('Are you sure you want to PERMANENTLY DELETE this user?')) {
                    fetch('/admin/delete-user', { 
                        method: 'POST', 
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ userId: userId })
                    })
                    .then(r => r.json())
                    .then(d => { if(d.success) location.reload(); else alert('Failed to delete'); });
                }
            }
        </script>
        <style>
            /* Fixed Scrolling for Admin Container */
            .admin-container { 
                padding: 20px; 
                display: grid; 
                grid-template-columns: repeat(4, 1fr); 
                grid-gap: 20px; 
                overflow-y: auto; 
                height: 100%; 
                box-sizing: border-box;
                padding-bottom: 50px; 
            }
            .stat-card { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); display:flex; flex-direction:column; justify-content:space-between; }
            .stat-title { color: #6c757d; font-size: 0.85rem; font-weight: bold; text-transform: uppercase; margin-bottom: 10px; }
            .stat-value { font-size: 1.8rem; font-weight: 700; color: #1c1c1e; }
            .stat-sub { font-size: 0.8rem; color: #28a745; margin-top: 5px; }
            .chart-box { grid-column: 1 / -1; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); height: 350px; }
            .table-box { grid-column: 1 / 3; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); overflow-x:auto; }
            .info-box { grid-column: 3 / 5; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
            
            table.admin-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
            table.admin-table th { text-align: left; padding: 12px; border-bottom: 2px solid #f0f2f5; color: #6c757d; font-size: 0.85rem; }
            table.admin-table td { padding: 12px; border-bottom: 1px solid #f0f2f5; font-size: 0.9rem; }
            table.admin-table tr:last-child td { border-bottom: none; }
            .badge { padding: 4px 8px; border-radius: 12px; font-size: 0.75rem; font-weight: bold; }
            .badge-on { background: #e6f4ea; color: #1e8e3e; }
            .badge-off { background: #fce8e6; color: #d93025; }
            
            @media(max-width: 900px) {
                .admin-container { grid-template-columns: 1fr; display: flex; flex-direction: column; overflow-y: auto; height: auto; }
                .table-box, .info-box { grid-column: 1 / -1; }
            }
        </style>
        
        <div class="admin-container">
            <div class="stat-card">
                <div class="stat-title">Total Users</div>
                <div class="stat-value">${activeUsers}</div>
                <div class="stat-sub">+${analytics.registrations} New</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">Page Views</div>
                <div class="stat-value">${totalViews}</div>
                <div class="stat-sub">Live Tracking</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">Bot Activations</div>
                <div class="stat-value">${botStarts}</div>
                <div class="stat-sub">System Wide</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">System PnL</div>
                <div class="stat-value" style="color:${systemPnl>=0?'#1e8e3e':'#d93025'}">$${systemPnl.toFixed(2)}</div>
                <div class="stat-sub">Realized</div>
            </div>

            <div class="chart-box">
                <canvas id="trafficChart"></canvas>
            </div>

            <div class="table-box">
                <h3 style="margin-top:0;">User Management</h3>
                <table class="admin-table">
                    <thead>
                        <tr>
                            <th>User</th>
                            <th>Mode</th>
                            <th>Bot</th>
                            <th>Balance</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                    ${users.map(u => {
                        const curr = CURRENCIES[u.currency || 'USD'];
                        const sym = curr.symbol;
                        const rate = curr.rate;
                        const virtBal = u.virtual && u.virtual.balance ? (u.virtual.balance * rate).toFixed(2) : '0.00';
                        return `<tr>
                            <td><strong>${u.username}</strong></td>
                            <td><span class="badge ${u.mode==='real'?'badge-off':'badge-on'}">${u.mode.toUpperCase()}</span></td>
                            <td><span class="badge ${u.bot.active?'badge-on':'badge-off'}">${u.bot.active ? 'ACTIVE' : 'IDLE'}</span></td>
                            <td>${sym}${virtBal}</td>
                            <td><button onclick="deleteUser('${u.id}')" class="btn btn-sell" style="padding:4px 8px; font-size:0.7rem; width:auto;">Delete</button></td>
                        </tr>`;
                    }).join('')}
                    </tbody>
                </table>
            </div>

            <div class="info-box">
                <h3 style="margin-top:0;">Top Pages</h3>
                <ul style="list-style:none; padding:0;">
                    ${topPages.map(p => `<li style="padding:10px 0; border-bottom:1px solid #eee; display:flex; justify-content:space-between;">
                        <span>${p[0]}</span> <span style="font-weight:bold;">${p[1]}</span>
                    </li>`).join('')}
                </ul>
                
                <div style="margin-top:30px; padding-top:20px; border-top:1px solid #eee;">
                    <h4 style="color:#d93025; margin-top:0;">Danger Zone</h4>
                    <form action="/admin/reset-db" method="POST" onsubmit="return confirm('âš ï¸ WARNING: THIS WILL DELETE ALL DATA. CONTINUE?');">
                        <button class="btn btn-sell" style="font-size:0.8rem;">RESET DATABASE</button>
                    </form>
                </div>
            </div>
        </div>

        <script>
            const ctx = document.getElementById('trafficChart').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ${JSON.stringify(chartLabels)},
                    datasets: [{
                        label: 'Page Views (Current Server Time)',
                        data: ${JSON.stringify(chartData)},
                        borderColor: '#6200ea',
                        backgroundColor: 'rgba(98, 0, 234, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: true } },
                    scales: { y: { beginAtZero: true } }
                }
            });
        </script>
        `, null));
    }
    res.send(renderLayout('Admin Login', `<div style="display:flex; justify-content:center; align-items:center; height:100vh;"><div class="card" style="width:100%; max-width:400px; text-align:center;"><form method="POST" action="/admin/login"><h3>Admin Login</h3><div class="input-group"><label>User</label><input type="text" name="user"></div><div class="input-group"><label>Pass</label><input type="password" name="pass"></div><button class="btn btn-primary">Login</button></form></div></div>`, null));
});
app.post('/admin/login', (req, res) => { if(req.body.user === 'admin' && req.body.pass === 'password') req.session.isAdmin = true; res.redirect('/admin'); });

// NEW: Delete User Endpoint
app.post('/admin/delete-user', async (req, res) => {
    if(req.session.isAdmin) {
        const uid = req.body.userId;
        users = users.filter(u => u.id !== uid);
        await UserModel.deleteOne({ id: uid });
        saveDatabase();
        res.json({ success: true });
    } else {
        res.status(403).json({ success: false });
    }
});

app.post('/admin/reset-db', async (req, res) => {
    if(req.session.isAdmin) {
        try {
            await UserModel.deleteMany({});
            await AnalyticsModel.deleteMany({});
            users = []; 
            analytics = { pageViews: [], totalViews: 0, clicks: [], registrations: 0, botStarts: 0 };
            console.log("âš ï¸ DATABASE RESET BY ADMIN");
            res.redirect('/admin');
        } catch(e) {
            res.send("Error resetting DB: " + e.message);
        }
    } else {
        res.status(403).send("Unauthorized");
    }
});

app.get('/profile', (req, res) => {
    const user = users.find(u => u.id === req.session.userId);
    if (!user) return res.redirect('/login');
    res.send(renderLayout('Profile', `
        <div style="display:flex; justify-content:center; align-items:center; height:100vh;">
            <div class="card" style="width:100%; max-width:400px;">
                <h3>User Profile</h3>
                <form action="/profile" method="POST">
                    <div class="input-group"><label>Username</label><input type="text" value="${user.username}" disabled style="color:#999;"></div>
                    
                    <div class="input-group">
                        <label>Display Currency</label>
                        <select name="currency">
                            <option value="USD" ${user.currency === 'USD' ? 'selected' : ''}>USD ($)</option>
                            <option value="GBP" ${user.currency === 'GBP' ? 'selected' : ''}>GBP (Â£)</option>
                            <option value="EUR" ${user.currency === 'EUR' ? 'selected' : ''}>EUR (â‚¬)</option>
                            <option value="ZAR" ${user.currency === 'ZAR' ? 'selected' : ''}>ZAR (R)</option>
                        </select>
                    </div>

                    <div class="input-group"><label>New Password (Optional)</label><input type="password" name="password" placeholder="Leave blank to keep current"></div>

                    <button class="btn btn-primary">Save Changes</button>
                </form>
            </div>
        </div>
    `, user));
});

app.post('/profile', (req, res) => {
    const user = users.find(u => u.id === req.session.userId);
    if(user) {
        user.currency = req.body.currency;
        if(req.body.password && req.body.password.length > 0) user.password = req.body.password;
        saveDatabase();
        res.redirect('/');
    } else {
        res.redirect('/login');
    }
});

// API Endpoints
app.post('/api/save-keys', (req, res) => {
    const user = users.find(u => u.id === req.session.userId);
    user.realKeys.apiKey = req.body.apiKey;
    user.realKeys.secret = req.body.secret;
    user.realClient = null; 
    saveDatabase();
    res.redirect('/');
});
app.post('/api/switch-mode', (req, res) => { 
    const user = users.find(u => u.id === req.session.userId); 
    user.mode = user.mode === 'virtual' ? 'real' : 'virtual'; 
    saveDatabase(); 
    res.json({ success: true }); 
});
app.post('/bot/add', (req, res) => { const user = users.find(u => u.id === req.session.userId); if(!user.bot.coins.find(c => c.symbol === req.body.symbol)) user.bot.coins.push({ symbol: req.body.symbol, side: (user.bot.coins.length%2===0?'buy':'sell'), lastAction:0, dcaCount:0 }); saveDatabase(); res.json({ success: true }); });
app.post('/bot/add-all', (req, res) => { const user = users.find(u => u.id === req.session.userId); let c=user.bot.coins.length; SUPPORTED_PAIRS.forEach(s => { if(!user.bot.coins.find(x=>x.symbol===s)) { user.bot.coins.push({ symbol:s, side: (c%2===0?'buy':'sell'), lastAction:0, dcaCount:0 }); c++; }}); saveDatabase(); res.json({ success: true }); });
app.post('/bot/remove', (req, res) => { const user = users.find(u => u.id === req.session.userId); user.bot.coins = user.bot.coins.filter(c => c.symbol !== req.body.symbol); saveDatabase(); res.json({ success: true }); });
app.post('/bot/clear', (req, res) => { const user = users.find(u => u.id === req.session.userId); user.bot.coins = []; user.bot.active = false; saveDatabase(); res.json({ success: true }); });
app.post('/bot/update', (req, res) => { 
    const user = users.find(u => u.id === req.session.userId); 
    user.bot.leverage = req.body.leverage; 
    user.bot.tradeAmount = req.body.tradeAmount; 
    user.bot.triggerRoi = req.body.triggerRoi;
    user.bot.recoveryRoi = req.body.recoveryRoi;
    user.bot.tradeMultiplier = req.body.tradeMultiplier;
    user.bot.profitRoi = req.body.profitRoi; 
    user.bot.stopLossRoi = req.body.stopLossRoi;
    user.bot.gradualDcaRoi = req.body.gradualDcaRoi; // NEW SETTING SAVE
    user.bot.active = !user.bot.active; 
    if(user.bot.active) analytics.botStarts++; 
    saveDatabase(); 
    res.json({ success: true }); 
});

// --- NEW MANUAL DCA ENDPOINT ---
app.post('/bot/manual-dca', async (req, res) => {
    const user = users.find(u => u.id === req.session.userId);
    const symbol = req.body.symbol;
    if(!user || !symbol) return res.json({ success: false, message: 'Invalid data' });

    try {
        const client = await getUserClient(user);
        await client.ensureMarkets();
        
        let positions = [];
        if(user.mode === 'real') {
             try { positions = await client.fetchPositions([symbol]); } catch(err) { return res.json({success:false, message: err.message}); }
        } else {
             positions = await client.fetchPositions([symbol]);
        }

        const pos = positions.find(p => p.symbol === symbol);
        if(!pos || parseFloat(pos.contracts) === 0) return res.json({ success: false, message: 'No open position to DCA' });

        const ticker = await client.fetchTicker(symbol);
        const currentPrice = ticker.last;
        const entryPrice = parseFloat(pos.entryPrice);
        const size = parseFloat(pos.contracts);
        const lev = parseFloat(pos.leverage || 10);
        
        // Calculate Qty to average down to recovery target
        const recoveryRoi = parseFloat(user.bot.recoveryRoi || -5);
        const targetRoiDec = recoveryRoi / 100;
        let targetAvgPrice = 0;
        
        if (pos.side === 'long') targetAvgPrice = currentPrice / (1 + (targetRoiDec / lev));
        else targetAvgPrice = currentPrice / (1 - (targetRoiDec / lev));
        
        let qtyNeeded = (size * (targetAvgPrice - entryPrice)) / (currentPrice - targetAvgPrice);
        if (qtyNeeded < 0) qtyNeeded = 0;
        if (qtyNeeded > size * 4) qtyNeeded = size * 4; // Safety cap
        if (qtyNeeded < 1) qtyNeeded = 1;
        
        const finalQty = Math.ceil(qtyNeeded);
        const forcedSide = pos.side === 'long' ? 'buy' : 'sell';

        await client.setMarginMode('cross', symbol);
        await client.createOrder(symbol, 'market', forcedSide, finalQty);
        
        saveDatabase();
        res.json({ success: true });

    } catch(e) {
        res.json({ success: false, message: e.message });
    }
});

app.post('/api/trade', async (req, res) => { 
    const user = users.find(u => u.id === req.session.userId); 
    try { 
        const client = await getUserClient(user); 
        await client.ensureMarkets();
        await client.setMarginMode('cross', req.body.symbol); 
        const leverage = parseInt(req.body.leverage) || 10;
        await client.setLeverage(leverage, req.body.symbol); 
        await client.createOrder(req.body.symbol, req.body.type, req.body.side, req.body.amount, req.body.price); 
        saveDatabase(); 
        res.json({ success: true }); 
    } catch (e) { res.json({ success: false, error: e.message }); } 
});
app.post('/api/close', async (req, res) => { const user = users.find(u => u.id === req.session.userId); try { const client = await getUserClient(user); await closePosition(client, req.body.symbol); saveDatabase(); res.json({ success: true }); } catch (e) { res.json({ success: false, error: e.message }); } });
app.post('/api/close-all', async (req, res) => { 
    const user = users.find(u => u.id === req.session.userId); 
    try { 
        const client = await getUserClient(user); 
        if (user.mode === 'real') {
             const positions = await client.fetchPositions();
             for (const pos of positions) {
                 if (parseFloat(pos.contracts) > 0) {
                     await closePosition(client, pos.symbol, pos);
                 }
             }
             await client.closeAllPositions();
        } 
        else {
            const positions = await client.fetchPositions(); 
            for(const pos of positions) { 
                try {
                    if(pos.contracts > 0) {
                        const closeSide = pos.side === 'long' ? 'sell' : 'buy';
                        await client.createOrder(pos.symbol, 'market', closeSide, pos.contracts);
                    }
                } catch(err) {
                    console.log(`Failed to close ${pos.symbol}: ${err.message}`);
                }
            } 
        }
        saveDatabase(); 
        res.json({ success: true }); 
    } catch (e) { res.json({ success: false, error: e.message }); } 
});
app.post('/api/set-balance', (req, res) => { const user = users.find(u => u.id === req.session.userId); const amt = parseFloat(req.body.amount); if(!isNaN(amt)) { const r = CURRENCIES[user.currency||'USD'].rate; user.virtual.balance = amt / r; saveDatabase(); } res.json({ success: true }); });
app.post('/api/reset-max-margin', (req, res) => { const user = users.find(u => u.id === req.session.userId); if(user.mode==='virtual') user.virtual.maxMarginUsed=0; else if(user.realClient) user.realClient.maxMarginUsed=0; saveDatabase(); res.json({ success: true }); });

app.post('/api/reset-pnl', (req, res) => {
    const user = users.find(u => u.id === req.session.userId);
    if(user.mode === 'virtual') {
        user.virtual.closedTrades = [];
    } else {
        if(!user.real) user.real = {};
        user.real.closedTrades = [];
        user.real.startBalance = null; 
    }
    saveDatabase();
    res.json({ success: true });
});

app.get('/api/orders', async (req, res) => { try { const client = await getUserClient(users.find(u=>u.id===req.session.userId)); const orders = await client.fetchOpenOrders(req.query.symbol); res.json(orders.map(o=>({id:o.id, side:o.side, price:o.price, amount:o.amount}))); } catch(e){ res.json([]); } });
app.get('/api/history', async (req, res) => { try { const client = await getUserClient(users.find(u=>u.id===req.session.userId)); const trades = await client.fetchMyTrades(req.query.symbol); res.json(trades.reverse().map(t=>({timestamp:t.timestamp, side:t.side, price:t.price, amount:t.amount, cost:t.cost}))); } catch(e){ res.json([]); } });

app.get('/api/closed-positions', async (req, res) => {
    try {
        const user = users.find(u => u.id === req.session.userId);
        let closed = [];
        if (user.mode === 'virtual') {
            closed = user.virtual.closedTrades || [];
        } else {
            if (!user.real) user.real = {};
            closed = user.real.closedTrades || [];
        }
        res.json(closed.slice(0, 50).map(t => ({
            timestamp: t.timestamp,
            symbol: t.symbol.replace('/USDT:USDT', ''),
            side: t.side,
            close: t.close,
            pnl: parseFloat(t.pnl).toFixed(8),
            roi: parseFloat(t.roi).toFixed(4)
        })));
    } catch(e) { res.json([]); }
});

app.get('/api/raw-positions', async (req, res) => { try { const user = users.find(u=>u.id===req.session.userId); const client = await getUserClient(user); const pos = await client.fetchPositions(); const rate = CURRENCIES[user.currency||'USD'].rate; res.json(pos.map(p=>({symbol:p.symbol, side:p.side, size:p.contracts, pnl:(p.unrealizedPnl*rate).toFixed(6), roi:p.roi, leverage:p.leverage, liquidationPrice:p.liquidationPrice}))); } catch(e){ res.json([]); } });
app.post('/api/cancel', async (req, res) => { try { const client = await getUserClient(users.find(u=>u.id===req.session.userId)); await client.cancelOrder(req.body.id, req.body.symbol); res.json({ success: true }); } catch(e){ res.json({}); } });
app.get('/api/position', async (req, res) => { 
    try { 
        const user = users.find(u=>u.id===req.session.userId); 
        const client = await getUserClient(user); 
        
        const allPositions = await client.fetchPositions();
        const bal = await client.fetchBalance();
        const walletBalance = parseFloat(bal.USDT.total || 0);
        const totalEquity = walletBalance;

        const pos = allPositions.find(p => p.symbol === req.query.symbol) || {};
        
        let closedPnl = 0;
        let recentPnl = 0; 
        const now = Date.now();
        const oneDay = 24 * 60 * 60 * 1000;
        
        if (user.mode === 'real') {
            if (!user.real) user.real = {};
            if (user.real.startBalance === undefined || user.real.startBalance === null) {
                user.real.startBalance = walletBalance;
                saveDatabase();
            }
            closedPnl = walletBalance - user.real.startBalance;
            const tradeHistory = user.real.closedTrades || [];
            if(tradeHistory.length > 0) {
                 recentPnl = tradeHistory.filter(t => (now - t.timestamp) < oneDay).reduce((a, t) => a + (t.pnl || 0), 0);
            }
        } else {
            let tradeHistory = user.virtual.closedTrades || [];
            if(tradeHistory.length > 0) {
                 closedPnl = tradeHistory.reduce((a,t)=>a+(t.pnl||0),0);
                 recentPnl = tradeHistory.filter(t => (now - t.timestamp) < oneDay).reduce((a, t) => a + (t.pnl || 0), 0);
            }
        }
        
        const r = CURRENCIES[user.currency||'USD'].rate; const s = CURRENCIES[user.currency||'USD'].symbol;
        const estDay = recentPnl;
        const estHour = estDay / 24;
        const estYear = estDay * 365; // Annualized

        const usedMargin = parseFloat(bal.USDT.used || 0);
        const freeMargin = parseFloat(bal.USDT.free || 0);
        const maxMargin = (user.mode === 'real' ? (client.maxMarginUsed || 0) : (user.virtual.maxMarginUsed || 0));

        res.json({ 
            upnl:((pos.unrealizedPnl||0)*r).toFixed(4), 
            closedPnl:(closedPnl*r).toFixed(4), 
            roi:(pos.roi||0).toFixed(2)+'%', 
            marginUsed: s + (usedMargin * r).toFixed(2),
            marginFree: s + (freeMargin * r).toFixed(2),
            maxMargin: s + (maxMargin * r).toFixed(2),
            balance: s + (totalEquity * r).toFixed(2),
            estHour: s + (estHour*r).toFixed(2),
            estYear: s + (estYear*r).toFixed(2),
        }); 
    } catch(e){ res.json({ upnl:'0.00', closedPnl:'0.00', roi:'0.00%', marginUsed:'0.00', marginFree:'0.00', maxMargin:'0.00', balance:'...', estHour:'0.00', estYear:'0.00' }); } 
});

app.get('/login', (req, res) => res.send(renderLayout('Login', `<div style="display:flex; justify-content:center; align-items:center; height:100vh;"><div class="card" style="width:100%; max-width:400px; text-align:center;"><h3>Login</h3><form action="/login" method="POST"><div class="input-group"><label>Username</label><input type="text" name="username"></div><div class="input-group"><label>Password</label><input type="password" name="password"></div><button class="btn btn-primary" style="margin-top:10px;">Login</button></form><a href="/register" style="font-size:0.8rem; display:block; margin-top:15px; color:#5f6368; text-decoration:none;">Create Account</a></div></div>`, null)));
app.post('/login', (req, res) => { const u = users.find(u => u.username === req.body.username && u.password === req.body.password); if(u) { req.session.userId = u.id; res.redirect('/'); } else res.redirect('/login'); });
app.get('/register', (req, res) => res.send(renderLayout('Register', `<div style="display:flex; justify-content:center; align-items:center; height:100vh;"><div class="card" style="width:100%; max-width:400px; text-align:center;"><h3>Register</h3><form action="/register" method="POST"><div class="input-group"><label>Username</label><input type="text" name="username"></div><div class="input-group"><label>Password</label><input type="password" name="password"></div><button class="btn btn-primary" style="margin-top:10px;">Sign Up</button></form></div></div>`, null)));
app.post('/register', (req, res) => { 
    // UPDATED: Added Default gradualDcaRoi: -999 (Disabled by default)
    const newUser = { id: crypto.randomBytes(8).toString('hex'), username: req.body.username, password: req.body.password, currency: 'USD', mode: 'virtual', realKeys: { apiKey: '', secret: '' }, bot: { active: false, coins: [], leverage: 10, tradeType: 'usdt', tradeAmount: 10, tradeMultiplier: 1, triggerRoi: -15, recoveryRoi: -5, profitRoi: 6, stopLossRoi: -50, gradualDcaRoi: -999 }, virtual: { balance: STARTING_BALANCE, positions: {}, orders: [], trades: [], closedTrades: [], maxMarginUsed: 0 }, real: { closedTrades: [] }, client: null };
    users.push(newUser); analytics.registrations++; saveDatabase(); req.session.userId = newUser.id; res.redirect('/'); 
});
app.get('/logout', (req, res) => { req.session.destroy(); res.redirect('/login'); });

// --- UPDATED NEWS ROUTES ---
app.get('/news', (req, res) => getNewsData(articles => {
    const listHtml = (articles||[]).map(a => {
        const slug = slugify(a.title);
        const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(a.title)}`;
        return `
        <div class="card" style="margin-bottom:15px; height:auto; display:block;">
            <h3 style="margin-bottom:5px;"><a href="/news/view/${slug}" style="text-decoration:none; color:var(--primary);">${a.title}</a></h3>
            <div style="font-size:0.75rem; color:#999; margin-bottom:10px;">${new Date(a.publishedAt).toLocaleString()}</div>
            <p>${a.description || 'No description available.'}</p>
            <div style="display:flex; gap:10px; margin-top:10px;">
                <a href="/news/view/${slug}" class="btn btn-primary" style="width:auto; text-decoration:none; display:inline-block; padding:8px 16px;">Read More</a>
                <a href="${searchUrl}" target="_blank" class="btn btn-text" style="width:auto; text-decoration:none; display:inline-block; padding:8px 16px;">ðŸ” Search Web</a>
            </div>
        </div>`;
    }).join('');
    
    // Explicit inline style to fix scrolling on news page by overriding grid layout
    res.send(renderLayout('Crypto News', `<div class="container" style="display:block; overflow-y:auto; height:100%; padding:20px;"><h2>Latest Market News</h2>${listHtml}</div>`, users.find(u=>u.id===req.session.userId)));
}));

app.get('/news/view/:slug', (req, res) => getNewsData(articles => {
    const a = (articles||[]).find(ar => slugify(ar.title) === req.params.slug);
    if(a) {
        const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(a.title + ' cryptocurrency news')}`;
        const content = `
        <div class="container" style="display:block; overflow-y:auto; height:100%; padding:20px;">
            <div class="card" style="height:auto; display:block;">
                <a href="/news" style="color:var(--text-secondary); text-decoration:none; font-weight:bold;">â† Back to News</a>
                <h1 style="margin-top:15px; font-size:1.8rem;">${a.title}</h1>
                <img src="${a.urlToImage}" style="max-width:100%; border-radius:8px; margin:15px 0; display:block;" onerror="this.style.display='none'">
                <p style="line-height:1.6; font-size:1.1rem; color:var(--text);">${a.content || a.description || 'Content unavailable.'}</p>
                <div style="margin-top:20px; padding-top:20px; border-top:1px solid #eee;">
                    <a href="${a.url}" target="_blank" class="btn btn-primary" style="width:auto; display:inline-block; text-decoration:none; margin-right:10px;">Read Original Source</a>
                    <a href="${searchUrl}" target="_blank" class="btn btn-text" style="width:auto; display:inline-block; text-decoration:none;">ðŸ” Search Related Topics</a>
                </div>
            </div>
        </div>`;
        res.send(renderLayout(a.title, content, users.find(u=>u.id===req.session.userId)));
    } else {
        res.redirect('/news');
    }
}));

// ==========================================
// 8. DB CONNECTION & STARTUP
// ==========================================
mongoose.connect(MONGO_URI)
    .then(() => {
        console.log("âœ… CLOUD: Connected to MongoDB Atlas");
        return loadDatabase();
    })
    .then(() => {
        server.listen(PORT, () => console.log(`ðŸš€ SYSTEM ONLINE: http://localhost:${PORT}`));
        runBotLogic(); 
    })
    .catch(err => {
        console.error("âŒ STARTUP ERROR: Could not connect to MongoDB.", err.message);
    });

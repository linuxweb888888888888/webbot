/******************************************************************************************
 * ⚡ GENIUS BOT — FULL DASHBOARD (MARGIN SAFE)
 * AUTO ADJUST QTY TO TARGET ROI + TREND + CORRECT ROI
 * INSTANT TREND REVERSAL (WAIT UNTIL POSITION = 0)
 * SCALE QTY / PARTIAL CLOSE QTY BASED ON TOTAL EQUITY
 * PARTIAL CLOSE RULE:
 *   - ONLY if ROI >= PARTIAL_CLOSE_ROI
 *   - QTY 1–9  → PARTIAL CLOSE QTY = 1
 *   - QTY >=10 → PARTIAL CLOSE QTY = floor(QTY / 10)
 * LIQUIDATION DEFENSE: ONLY ADDS TO POSITION, NEVER CLOSES (~2%, MAX 400)
 * HARD STOP LOSS AT -25% ROI
 ******************************************************************************************/

require('dotenv').config();
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const ccxt = require('ccxt');
const minimist = require('minimist');

const args = minimist(process.argv.slice(2));
const COIN = args.coin?.toUpperCase() || 'ADA';
const PORT = parseInt(args.port) || 3000;

const CONFIG = {
    PRICE_SYMBOL: `${COIN}/USDT`,
    ORDER_SYMBOL: `${COIN}/USDT:USDT`,
    LOOKBACK_PERIOD: 50,
    PRICE_RATE: 2000,
    PARTIAL_CLOSE_ROI: 10,
    LIQ_DEFENSE_THRESHOLD: 1,
    MAX_EXPOSURE_QTY: 100000000,
    MAX_DEFEND_QTY: 400,
};

const state = {
    positions: { qty: 0, entry: 0, side: null, unrealizedPnl: 0, liquidationPrice: 0 },
    liquidationDefenseQty: 0,
    distanceToLiq: 0,
    prevDistanceToLiq: 0,
    history: [],
    price: 0,
    bid: 0,
    ask: 0,
    support: 0,
    resistance: 0,
    status: 'INIT',
    roiPercent: 0,
    availableMargin: 0,
    SCALE_QTY: 1,
    PARTIAL_CLOSE_QTY: 0,
    lastPriceForLiqDefense: null,
    lastLiqTime: 0
};

function isExposureCapped() {
    return Math.abs(state.positions.qty) >= CONFIG.MAX_EXPOSURE_QTY;
}

const exchange = new ccxt.phemex({
    apiKey: process.env.PHEMEX_KEY,
    secret: process.env.PHEMEX_SECRET,
    enableRateLimit: true,
    timeout: 30000,
    options: { defaultType: 'swap' }
});

// ================= PRICE =================
async function fetchPrice() {
    const t = await exchange.fetchTicker(CONFIG.PRICE_SYMBOL);
    state.bid = t.bid;
    state.ask = t.ask;
    state.price = (t.bid + t.ask) / 2;

    state.history.push({ time: Date.now(), price: state.price });
    state.history = state.history.filter(p => p.time >= Date.now() - 5 * 60 * 1000);
}

// ================= MARGIN =================
async function fetchMargin() {
    try {
        const bal = await exchange.fetchBalance();
        state.availableMargin = bal.free?.USDT ?? 0;
    } catch {
        state.availableMargin = 0;
    }
}

// ================= TOUCH MARGIN =================
function getDynamicTouchMargin() {
    const prices = state.history.slice(-CONFIG.LOOKBACK_PERIOD).map(h => h.price);
    if (prices.length < 2) return 0.1;
    const high = Math.max(...prices);
    const low = Math.min(...prices);
    return Math.max(((high - low) / low) * 10, 0.05);
}

// ================= POSITIONS =================
async function syncPositions() {
    try {
        const pos = (await exchange.fetchPositions())
            .find(p => p.symbol === CONFIG.ORDER_SYMBOL) || {};

        const qty = Number(pos.contracts || 0);
        const entry = Number(pos.entryPrice || 0);
        const liq = Number(pos.liquidationPrice || 0);

        state.positions = qty > 0
            ? { qty, entry, side: pos.side === 'long' ? 'LONG' : 'SHORT', unrealizedPnl: Number(pos.unrealizedPnl || 0), liquidationPrice: liq }
            : { qty: 0, entry: 0, side: null, unrealizedPnl: 0, liquidationPrice: 0 };

        state.roiPercent = pos.initialMargin
            ? (pos.unrealizedPnl / pos.initialMargin) * 100
            : 0;

        state.prevDistanceToLiq = state.distanceToLiq;

        if (qty > 0 && liq > 0) {
            state.distanceToLiq =
                state.positions.side === 'LONG'
                    ? ((state.price - liq) / liq) * 100
                    : ((liq - state.price) / liq) * 100;
            state.distanceToLiq = Math.max(state.distanceToLiq, 0);
        } else {
            state.distanceToLiq = 0;
        }

        if (qty > 0) {
            state.SCALE_QTY = Math.min(
                Math.max(Math.floor((state.availableMargin * 0.1) / state.price), 1),
                CONFIG.MAX_EXPOSURE_QTY - qty
            );

            state.PARTIAL_CLOSE_QTY =
                state.roiPercent >= CONFIG.PARTIAL_CLOSE_ROI
                    ? (qty < 10 ? 1 : Math.floor(qty / 10))
                    : 0;
        } else {
            state.SCALE_QTY = Math.min(
                Math.max(Math.floor((state.availableMargin * 0.1) / state.price), 1),
                CONFIG.MAX_EXPOSURE_QTY
            );
            state.PARTIAL_CLOSE_QTY = 0;
        }

    } catch (err) {
        console.error('Failed to fetch positions:', err.message);
        state.positions = { qty: 0, entry: 0, side: null, unrealizedPnl: 0, liquidationPrice: 0 };
        state.roiPercent = 0;
        state.prevDistanceToLiq = state.distanceToLiq;
        state.distanceToLiq = 0;
    }
}

// ================= ORDERS =================
async function placeOrder(side, qty, ignoreMargin = false) {
    if (qty <= 0) return;

    await syncPositions();
    const posQty = state.positions.qty;

    if (!ignoreMargin && qty * state.price * 0.02 > state.availableMargin) return;
    if (isExposureCapped()) return;
    if (posQty + qty > CONFIG.MAX_EXPOSURE_QTY) qty = CONFIG.MAX_EXPOSURE_QTY - posQty;
    if (qty <= 0) return;

    try {
        const order = await exchange.createOrder(CONFIG.ORDER_SYMBOL, 'market', side, qty);

        const checkOrderFill = async () => {
            try {
                const fetched = await exchange.fetchOrder(order.id, CONFIG.ORDER_SYMBOL);
                if (fetched.status === 'closed' || fetched.status === 'filled') {
                    await syncPositions();
                } else {
                    setTimeout(checkOrderFill, 200);
                }
            } catch {
                setTimeout(checkOrderFill, 500);
            }
        };
        checkOrderFill();
    } catch (err) {
        console.error('Order error:', err.message);
    }
}

// ================= STRATEGY =================
async function strategy(io) {
    state.liquidationDefenseQty = 0;

    await fetchPrice();
    await fetchMargin();
    await syncPositions();

    const pos = state.positions;
    const prices = state.history.slice(-CONFIG.LOOKBACK_PERIOD).map(h => h.price);

    state.support = prices.length ? Math.min(...prices) : state.price;
    state.resistance = prices.length ? Math.max(...prices) : state.price;

    // ---------------- HARD STOP LOSS ----------------
    if (pos.qty > 0 && state.roiPercent <= -25) {
        await placeOrder(pos.side === 'LONG' ? 'sell' : 'buy', pos.qty, true);
        state.status = 'STOP LOSS -25%';
        await syncPositions();
        return;
    }

    // ---------------- PARTIAL CLOSE ----------------
    if (pos.qty > 0 && state.roiPercent >= CONFIG.PARTIAL_CLOSE_ROI) {
        const partialQty = pos.qty < 10 ? 1 : Math.floor(pos.qty / 10);
        if (partialQty > 0) {
            console.log(`Partial Close: ${partialQty} ${pos.side}`);
            await placeOrder(pos.side === 'LONG' ? 'sell' : 'buy', partialQty, true);
            state.status = 'PARTIAL CLOSE';
            await syncPositions();
            return; // skip other trades this interval
        }
    }

    // ---------------- LIQUIDATION DEFENSE ----------------
    // Only adds to position, never closes
    const LIQ_WAIT_MS = 3000;
    if (
        pos.qty > 0 &&
        state.distanceToLiq < CONFIG.LIQ_DEFENSE_THRESHOLD &&
        state.roiPercent <= 0 &&
        !isExposureCapped() &&
        state.distanceToLiq < state.prevDistanceToLiq
    ) {
        const now = Date.now();
        if (state.lastPriceForLiqDefense !== state.price || now - state.lastLiqTime > LIQ_WAIT_MS) {
            const deficitPct = CONFIG.LIQ_DEFENSE_THRESHOLD - state.distanceToLiq;
            let qtyToDefend = Math.ceil((deficitPct / CONFIG.LIQ_DEFENSE_THRESHOLD) * pos.qty * 0.02);

            qtyToDefend = Math.min(Math.max(1, qtyToDefend), CONFIG.MAX_DEFEND_QTY);
            if (pos.qty + qtyToDefend > CONFIG.MAX_EXPOSURE_QTY) {
                qtyToDefend = CONFIG.MAX_EXPOSURE_QTY - pos.qty;
            }

            if (qtyToDefend > 0) {
                const side = pos.side === 'LONG' ? 'buy' : 'sell';
                await placeOrder(side, qtyToDefend);
                state.liquidationDefenseQty = qtyToDefend;
                state.status = 'LIQUIDATION DEFENSE';
                state.lastPriceForLiqDefense = state.price;
                state.lastLiqTime = now;
            }
        }
    }

    // ---------------- TREND ENTRY ----------------
    if (pos.qty === 0 && state.history.length >= 5) {
        const trend = state.history[state.history.length - 1].price - state.history[state.history.length - 5].price;
        const side = trend > 0 ? 'buy' : 'sell';
        const qty = Math.min(state.SCALE_QTY, CONFIG.MAX_EXPOSURE_QTY);
        if (qty > 0) {
            await placeOrder(side, qty);
            state.status = `TREND ENTRY (${side === 'buy' ? 'LONG' : 'SHORT'})`;
        }
    }

    if (isExposureCapped()) {
        state.status = 'EXPOSURE CAPPED — PARTIAL CLOSE ONLY';
    }

    // ---------------- DASHBOARD EMIT ----------------
    io.emit('stats', {
        price: state.price,
        bid: state.bid,
        ask: state.ask,
        support: state.support,
        resistance: state.resistance,
        posType: pos.side || 'NONE',
        qty: pos.qty,
        entry: pos.entry,
        liquidationPrice: pos.liquidationPrice,
        liquidationDefenseQty: state.liquidationDefenseQty,
        distanceToLiq: state.distanceToLiq,
        status: state.status,
        roiPercent: state.roiPercent,
        availableMargin: state.availableMargin,
        scaleQty: state.SCALE_QTY,
        partialQty: state.PARTIAL_CLOSE_QTY,
        touchMargin: getDynamicTouchMargin().toFixed(4)
    });
}

// ================= SERVER =================
const app = express();
const server = http.createServer(app);
const io = new Server(server);

app.get('/', (_, res) => res.send(DASHBOARD_HTML));

server.listen(PORT, () => {
    console.log(`Dashboard running http://localhost:${PORT}`);
    setInterval(() => strategy(io), CONFIG.PRICE_RATE);
});

// ================= DASHBOARD HTML =================
const DASHBOARD_HTML = `
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GENIUS BOT — ${COIN}/USDT</title>
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@4/dist/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
:root{--bg:#f5f6fa;--card:#fff;--text:#1f2937;--muted:#6b7280;
--green:#16a34a;--red:#dc2626;--shadow:0 8px 24px rgba(0,0,0,.08)}
body{margin:0;background:var(--bg);font-family:Inter,sans-serif;color:var(--text)}
.container{max-width:1200px;margin:auto;padding:16px}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px}
.card{background:var(--card);border-radius:14px;padding:12px;box-shadow:var(--shadow);text-align:center}
.label{font-size:11px;color:var(--muted)}
.value{font-family:monospace;font-size:14px;font-weight:600}
.pos-LONG{color:var(--green)}.pos-SHORT{color:var(--red)}
#chartWrap,#log{background:#fff;border-radius:14px;padding:10px;margin-top:16px;box-shadow:var(--shadow)}
#log{background:#111827;color:#e5e7eb;font-size:12px;height:160px;overflow:auto}
</style>
</head>
<body>
<div class="container">
<h1>GENIUS BOT — ${COIN}/USDT</h1>
<div class="grid">
<div class="card"><div class="label">PRICE</div><div class="value" id="p"></div></div>
<div class="card"><div class="label">POSITION</div><div class="value" id="pos"></div></div>
<div class="card"><div class="label">QTY</div><div class="value" id="q"></div></div>
<div class="card"><div class="label">ENTRY</div><div class="value" id="e"></div></div>
<div class="card"><div class="label">SUPPORT</div><div class="value" id="s"></div></div>
<div class="card"><div class="label">RESISTANCE</div><div class="value" id="r"></div></div>
<div class="card"><div class="label">ROI %</div><div class="value" id="roi"></div></div>
<div class="card"><div class="label">AVAILABLE MARGIN</div><div class="value" id="m"></div></div>
<div class="card"><div class="label">STATUS</div><div class="value" id="st"></div></div>
<div class="card"><div class="label">SCALE QTY</div><div class="value" id="scaleQty"></div></div>
<div class="card"><div class="label">PARTIAL CLOSE QTY</div><div class="value" id="partialQty"></div></div>
<div class="card"><div class="label">LIQUIDATION PRICE</div><div class="value" id="liq"></div></div>
<div class="card"><div class="label">LIQUIDATION DEFENSE QTY</div><div class="value" id="liqQty"></div></div>
<div class="card"><div class="label">DISTANCE TO LIQ %</div><div class="value" id="distLiq"></div></div>
<div class="card"><div class="label">TOUCH MARGIN %</div><div class="value" id="touchMargin"></div></div>
</div>
<div id="chartWrap"><canvas id="chart"></canvas></div>
<div id="log"></div>
</div>

<script>
const socket=new io(),log=document.getElementById('log');
const chart=new Chart(document.getElementById('chart'),{
type:'line',
data:{labels:[],datasets:[
{label:'Price',data:[],borderColor:'#2563eb',pointRadius:0},
{label:'Resistance',data:[],borderColor:'#dc2626',pointRadius:0,stepped:true},
{label:'Support',data:[],borderColor:'#16a34a',pointRadius:0,stepped:true}
]},options:{animation:false}
});

socket.on('stats',d=>{
p.innerText=d.price?.toFixed(6);
pos.innerText=d.posType;
pos.className='value '+(d.posType==='LONG'?'pos-LONG':d.posType==='SHORT'?'pos-SHORT':'');
q.innerText=d.qty;
e.innerText=d.entry?.toFixed(6);
s.innerText=d.support?.toFixed(6);
r.innerText=d.resistance?.toFixed(6);
roi.innerText=d.roiPercent?.toFixed(2)+'%';
roi.className='value '+(d.roiPercent>=0?'pos-LONG':'pos-SHORT');
m.innerText=d.availableMargin?.toFixed(6);
st.innerText=d.status;
scaleQty.innerText=d.scaleQty;
partialQty.innerText=d.partialQty;
liq.innerText=d.liquidationPrice ? d.liquidationPrice.toFixed(6) : '-';
liqQty.innerText=d.liquidationDefenseQty;
distLiq.innerText=d.distanceToLiq?.toFixed(2)+'%';
touchMargin.innerText=d.touchMargin+'%';

chart.data.labels.push(new Date().toLocaleTimeString());
chart.data.datasets[0].data.push(d.price);
chart.data.datasets[1].data.push(d.resistance);
chart.data.datasets[2].data.push(d.support);
if(chart.data.labels.length>200){
 chart.data.labels.shift();
 chart.data.datasets.forEach(x=>x.data.shift());
}
chart.update('none');
});
</script>
</body>
</html>
`;
